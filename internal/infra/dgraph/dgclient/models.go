// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package dgclient

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// A set of meta data collected and used by the crawler.
type CrawlerMeta interface {
	IsCrawlerMeta()
}

// An object with an ID.
type Node interface {
	IsNode()
}

type OuterDimensions interface {
	IsOuterDimensions()
}

type StringOrFloat interface {
	IsStringOrFloat()
}

type UserOrGroup interface {
	IsUserOrGroup()
}

type AddBoundingBoxDimensionsInput struct {
	Height float64 `json:"height"`
	Width  float64 `json:"width"`
	Depth  float64 `json:"depth"`
}

type AddBoundingBoxDimensionsPayload struct {
	BoundingBoxDimensions []*BoundingBoxDimensions `json:"boundingBoxDimensions"`
	NumUids               *int64                   `json:"numUids"`
}

type AddCategoryInput struct {
	// The human readable identifier of the category (lowercased fullName). For example: `hardware/cpu`
	Xid string `json:"xid"`
	// Full name of the category including the names of all parent categories. For example: `Hardware/CPU`.
	FullName string `json:"fullName"`
	// Name of this category. For example: `CPU`.
	Name string `json:"name"`
	// A short description of the category.
	Description *string        `json:"description,omitempty"`
	Parent      *CategoryRef   `json:"parent,omitempty"`
	Children    []*CategoryRef `json:"children,omitempty"`
	Products    []*ProductRef  `json:"products,omitempty"`
}

type AddCategoryPayload struct {
	Category []*Category `json:"category"`
	NumUids  *int64      `json:"numUids"`
}

type AddComponentInput struct {
	DiscoveredAt  time.Time     `json:"discoveredAt"`
	LastIndexedAt time.Time     `json:"lastIndexedAt"`
	DataSource    RepositoryRef `json:"dataSource"`
	//  The unique human readable identifier of the component in the format: `domain.tld/owner/repo/version/file-path/component-name`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml/baz`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-/baz`
	// - `oshwa.org/-/-/1.0.0/us000000.html/baz`
	Xid string `json:"xid"`
	// The name of the component.
	Name string `json:"name"`
	// The short description of the component.
	Description string `json:"description"`
	// The version string of the release.
	Version string `json:"version"`
	// The date and time when the release was created.
	CreatedAt time.Time       `json:"createdAt"`
	Releases  []*ComponentRef `json:"releases,omitempty"`
	// Indicates if this release is the latest release of the component.
	IsLatest           bool           `json:"isLatest"`
	Repository         RepositoryRef  `json:"repository"`
	License            *LicenseRef    `json:"license,omitempty"`
	AdditionalLicenses []*LicenseRef  `json:"additionalLicenses,omitempty"`
	Licensor           UserOrGroupRef `json:"licensor"`
	// The language in which the documentation is written.
	DocumentationLanguage string `json:"documentationLanguage"`
	// The OSH technology readiness level (OTRL) of the component. For information see:
	// https://github.com/OPEN-NEXT/OKH-LOSH/blob/master/OTRL.md
	TechnologyReadinessLevel TechnologyReadinessLevel `json:"technologyReadinessLevel"`
	// The OSH documentation readiness level (ODRL) of the component. For information see:
	// https://github.com/OPEN-NEXT/OKH-LOSH/blob/master/OTRL.md
	DocumentationReadinessLevel DocumentationReadinessLevel `json:"documentationReadinessLevel"`
	// The permanent URL to evidence of compliance (OSHWA, FSF, DIN SPEC 3105).
	Attestation *string `json:"attestation,omitempty"`
	// The scientific publication (DOI) in which the component has been peer reviewed.
	Publication  *string               `json:"publication,omitempty"`
	Issues       *string               `json:"issues,omitempty"`
	CompliesWith *TechnicalStandardRef `json:"compliesWith,omitempty"`
	// The international patent classification (IPC) of the component.
	CpcPatentClass            *string                                     `json:"cpcPatentClass,omitempty"`
	Tsdc                      *TechnologySpecificDocumentationCriteriaRef `json:"tsdc,omitempty"`
	Components                []*ComponentRef                             `json:"components,omitempty"`
	Software                  []*SoftwareRef                              `json:"software,omitempty"`
	Image                     *FileRef                                    `json:"image,omitempty"`
	Readme                    *FileRef                                    `json:"readme,omitempty"`
	ContributionGuide         *FileRef                                    `json:"contributionGuide,omitempty"`
	Bom                       *FileRef                                    `json:"bom,omitempty"`
	ManufacturingInstructions *FileRef                                    `json:"manufacturingInstructions,omitempty"`
	UserManual                *FileRef                                    `json:"userManual,omitempty"`
	Product                   *ProductRef                                 `json:"product,omitempty"`
	UsedIn                    []*ComponentRef                             `json:"usedIn,omitempty"`
	Source                    *FileRef                                    `json:"source,omitempty"`
	Export                    []*FileRef                                  `json:"export,omitempty"`
	Auxiliary                 []*FileRef                                  `json:"auxiliary,omitempty"`
	Organization              *GroupRef                                   `json:"organization,omitempty"`
	// The mass of the component in grams.
	Mass                 *float64                 `json:"mass,omitempty"`
	OuterDimensions      *OuterDimensionsRef      `json:"outerDimensions,omitempty"`
	Material             *MaterialRef             `json:"material,omitempty"`
	ManufacturingProcess *ManufacturingProcessRef `json:"manufacturingProcess,omitempty"`
	ProductionMetadata   []*KeyValueRef           `json:"productionMetadata,omitempty"`
}

type AddComponentPayload struct {
	Component []*Component `json:"component"`
	NumUids   *int64       `json:"numUids"`
}

type AddDatabaseInput struct {
	// The version of the database schema.
	Version string `json:"version"`
}

type AddDatabasePayload struct {
	Database []*Database `json:"database"`
	NumUids  *int64      `json:"numUids"`
}

type AddFileInput struct {
	DiscoveredAt  time.Time     `json:"discoveredAt"`
	LastIndexedAt time.Time     `json:"lastIndexedAt"`
	DataSource    RepositoryRef `json:"dataSource"`
	// The unique human readable identifier of the file in the format: `domain.tld/owner/repo/ref/file-path`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-`
	// - `oshwa.org/-/-/1.0.0/us000000.html`
	Xid string `json:"xid"`
	// The name of the file (without parent path).
	Name string `json:"name"`
	// The path of the file within the repository.
	Path string `json:"path"`
	// The mimetype of the file.
	MimeType *string `json:"mimeType,omitempty"`
	// The download URL of the file.
	URL string `json:"url"`
	// The date and time when the file was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`
}

type AddFilePayload struct {
	File    []*File `json:"file"`
	NumUids *int64  `json:"numUids"`
}

type AddFloatVInput struct {
	Value float64 `json:"value"`
}

type AddFloatVPayload struct {
	FloatV  []*FloatV `json:"floatV"`
	NumUids *int64    `json:"numUids"`
}

type AddGroupInput struct {
	Xid      string            `json:"xid"`
	Host     HostRef           `json:"host"`
	Name     string            `json:"name"`
	FullName *string           `json:"fullName,omitempty"`
	Email    *string           `json:"email,omitempty"`
	Avatar   *FileRef          `json:"avatar,omitempty"`
	URL      *string           `json:"url,omitempty"`
	MemberOf []*GroupRef       `json:"memberOf,omitempty"`
	Products []*ProductRef     `json:"products,omitempty"`
	Members  []*UserOrGroupRef `json:"members,omitempty"`
}

type AddGroupPayload struct {
	Group   []*Group `json:"group"`
	NumUids *int64   `json:"numUids"`
}

type AddHostInput struct {
	// The domain name of the host.
	Domain string `json:"domain"`
	// The nice name of the host.
	Name string `json:"name"`
}

type AddHostPayload struct {
	Host    []*Host `json:"host"`
	NumUids *int64  `json:"numUids"`
}

type AddKeyValueInput struct {
	Key   string           `json:"key"`
	Value StringOrFloatRef `json:"value"`
}

type AddKeyValuePayload struct {
	KeyValue []*KeyValue `json:"keyValue"`
	NumUids  *int64      `json:"numUids"`
}

type AddLicenseInput struct {
	// The human readable ID of the license. If the license is a SPDX license, the ID is the SPDX ID.
	Xid string `json:"xid"`
	// The full name of the license.
	Name string `json:"name"`
	// The full text of the license.
	Text *string `json:"text,omitempty"`
	// The full text of the license formatted as HTML.
	TextHTML *string `json:"textHTML,omitempty"`
	// The reference URL of the license with more information.
	ReferenceURL *string `json:"referenceURL,omitempty"`
	// The details URL of the license with information in machine readable format.
	DetailsURL *string `json:"detailsURL,omitempty"`
	// The type (strength) of the license.
	Type LicenseType `json:"type"`
	// Indicates if the license is a standard license.
	IsSpdx bool `json:"isSpdx"`
	// Indicates if the license identifier is deprecated in favor of another license identifier and should no longer be used.
	IsDeprecated bool `json:"isDeprecated"`
	// Indicates if the license is OSI approved.
	IsOsiApproved bool `json:"isOsiApproved"`
	// Indicates if the license is FSF approved.
	IsFsfLibre bool `json:"isFsfLibre"`
	// Indicates if the license is considered a LOSH unapproved license.
	IsBlocked bool `json:"isBlocked"`
}

type AddLicensePayload struct {
	License []*License `json:"license"`
	NumUids *int64     `json:"numUids"`
}

type AddManufacturingProcessInput struct {
	// The name of the manufacturing process.
	Name string `json:"name"`
	// The description of the manufacturing process.
	Description *string `json:"description,omitempty"`
}

type AddManufacturingProcessPayload struct {
	ManufacturingProcess []*ManufacturingProcess `json:"manufacturingProcess"`
	NumUids              *int64                  `json:"numUids"`
}

type AddMaterialInput struct {
	// The name of the material.
	Name string `json:"name"`
	// The description of the material.
	Description *string `json:"description,omitempty"`
}

type AddMaterialPayload struct {
	Material []*Material `json:"material"`
	NumUids  *int64      `json:"numUids"`
}

type AddOpenSCADDimensionsInput struct {
	Openscad string `json:"openscad"`
	Unit     string `json:"unit"`
}

type AddOpenSCADDimensionsPayload struct {
	OpenSCADDimensions []*OpenSCADDimensions `json:"openSCADDimensions"`
	NumUids            *int64                `json:"numUids"`
}

type AddProductInput struct {
	DiscoveredAt  time.Time     `json:"discoveredAt"`
	LastIndexedAt time.Time     `json:"lastIndexedAt"`
	DataSource    RepositoryRef `json:"dataSource"`
	//  The unique human readable identifier of the product in the format: `domain.tld/owner/repo/file-path`. For example:
	// - `github.com/aisbergg/foobar/okh.yml`
	// - `wikifactory.com/@aisbergg/foobar/-`
	// - `oshwa.org/-/-/us000000.html`
	Xid string `json:"xid"`
	// The name of the product.
	Name string `json:"name"`
	// The short description of the product.
	Description string `json:"description"`
	// The language in which the documentation is written.
	DocumentationLanguage string `json:"documentationLanguage"`
	// The latest version of the product.
	Version  string         `json:"version"`
	License  *LicenseRef    `json:"license,omitempty"`
	Licensor UserOrGroupRef `json:"licensor"`
	// The product website URL, if any.
	Website *string `json:"website,omitempty"`
	// Indicates if the product is still actively developed or not.
	State ProductState `json:"state"`
	// The date and time the product was last upated. This doesn't necessarily mean that a new release was created.
	LastUpdatedAt *time.Time      `json:"lastUpdatedAt,omitempty"`
	Release       ComponentRef    `json:"release"`
	Releases      []*ComponentRef `json:"releases"`
	RenamedTo     *ProductRef     `json:"renamedTo,omitempty"`
	RenamedFrom   *ProductRef     `json:"renamedFrom,omitempty"`
	ForkOf        *ProductRef     `json:"forkOf,omitempty"`
	Forks         []*ProductRef   `json:"forks,omitempty"`
	// The number of forks of the product. It might be higher than the number of indexed forks, because not all forks might satisfy the conditions for being indexed.
	ForkCount *int64 `json:"forkCount,omitempty"`
	// The number of people starring the product.
	StarCount *int64       `json:"starCount,omitempty"`
	Tags      []*TagRef    `json:"tags,omitempty"`
	Category  *CategoryRef `json:"category,omitempty"`
}

type AddProductPayload struct {
	Product []*Product `json:"product"`
	NumUids *int64     `json:"numUids"`
}

type AddRepositoryInput struct {
	//  The unique human readable identifier of the repository in the format: `domain.tld/owner/repo/ref/file-path`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-`
	// - `oshwa.org/-/-/1.0.0/us000000.html`
	Xid string `json:"xid"`
	// Nice URL of the repository where the result is The repository URL where the component was discoverd from or is developed in.
	URL string `json:"url"`
	// The permanent URL to the specific release version.
	PermaURL string          `json:"permaUrl"`
	Host     HostRef         `json:"host"`
	Owner    *UserOrGroupRef `json:"owner,omitempty"`
	// The repository name, if any.
	Name *string `json:"name,omitempty"`
	// The reference, if any. This could be a Git tag or branch for example.
	Reference *string `json:"reference,omitempty"`
	// The path of the file or other resource inside the repository, if any.
	Path *string  `json:"path,omitempty"`
	File *FileRef `json:"file,omitempty"`
}

type AddRepositoryPayload struct {
	Repository []*Repository `json:"repository"`
	NumUids    *int64        `json:"numUids"`
}

type AddSoftwareInput struct {
	DiscoveredAt          time.Time     `json:"discoveredAt"`
	LastIndexedAt         time.Time     `json:"lastIndexedAt"`
	DataSource            RepositoryRef `json:"dataSource"`
	Release               *string       `json:"release,omitempty"`
	InstallationGuide     *FileRef      `json:"installationGuide,omitempty"`
	DocumentationLanguage *string       `json:"documentationLanguage,omitempty"`
	License               *LicenseRef   `json:"license,omitempty"`
	Licensor              *string       `json:"licensor,omitempty"`
}

type AddSoftwarePayload struct {
	Software []*Software `json:"software"`
	NumUids  *int64      `json:"numUids"`
}

type AddStringVInput struct {
	Value string `json:"value"`
}

type AddStringVPayload struct {
	StringV []*StringV `json:"stringV"`
	NumUids *int64     `json:"numUids"`
}

type AddTagInput struct {
	// The human readable identifier of the tag.
	Xid string `json:"xid"`
	// The name of the tag.
	Name    string    `json:"name"`
	Aliases []*TagRef `json:"aliases,omitempty"`
	Related []*TagRef `json:"related,omitempty"`
}

type AddTagPayload struct {
	Tag     []*Tag `json:"tag"`
	NumUids *int64 `json:"numUids"`
}

type AddTechnicalStandardInput struct {
	// The human readable identifier of the standard (lowercased name). For example: "din en 1335".
	Xid string `json:"xid"`
	// The name of the standard. For example: "DIN EN 1335".
	Name string `json:"name"`
	// The description for the standard.
	Description *string         `json:"description,omitempty"`
	Components  []*ComponentRef `json:"components,omitempty"`
}

type AddTechnicalStandardPayload struct {
	TechnicalStandard []*TechnicalStandard `json:"technicalStandard"`
	NumUids           *int64               `json:"numUids"`
}

type AddTechnologySpecificDocumentationCriteriaInput struct {
	// The human readable identifier of the standard (lowercased name). For example: "mec".
	Xid string `json:"xid"`
	// The nice name of the criteria. For example: "MEC".
	Name string `json:"name"`
	// An optional comment for the criteria.
	Comment *string `json:"comment,omitempty"`
	// The URI to a document stating the corresponding requirements.
	RequirementsURI *string         `json:"requirementsUri,omitempty"`
	Components      []*ComponentRef `json:"components,omitempty"`
}

type AddTechnologySpecificDocumentationCriteriaPayload struct {
	TechnologySpecificDocumentationCriteria []*TechnologySpecificDocumentationCriteria `json:"technologySpecificDocumentationCriteria"`
	NumUids                                 *int64                                     `json:"numUids"`
}

type AddUserInput struct {
	Xid      string        `json:"xid"`
	Host     HostRef       `json:"host"`
	Name     string        `json:"name"`
	FullName *string       `json:"fullName,omitempty"`
	Email    *string       `json:"email,omitempty"`
	Avatar   *FileRef      `json:"avatar,omitempty"`
	URL      *string       `json:"url,omitempty"`
	MemberOf []*GroupRef   `json:"memberOf,omitempty"`
	Products []*ProductRef `json:"products,omitempty"`
	// Localization of the user.
	Locale *string `json:"locale,omitempty"`
}

type AddUserPayload struct {
	User    []*User `json:"user"`
	NumUids *int64  `json:"numUids"`
}

type AuthRule struct {
	And  []*AuthRule `json:"and,omitempty"`
	Or   []*AuthRule `json:"or,omitempty"`
	Not  *AuthRule   `json:"not,omitempty"`
	Rule *string     `json:"rule,omitempty"`
}

// A type of dimension in form of a box. Unit: m
type BoundingBoxDimensions struct {
	ID     string  `json:"id"`
	Height float64 `json:"height"`
	Width  float64 `json:"width"`
	Depth  float64 `json:"depth"`
}

func (BoundingBoxDimensions) IsOuterDimensions() {}
func (BoundingBoxDimensions) IsNode()            {}

type BoundingBoxDimensionsAggregateResult struct {
	Count     *int64   `json:"count"`
	HeightMin *float64 `json:"heightMin"`
	HeightMax *float64 `json:"heightMax"`
	HeightSum *float64 `json:"heightSum"`
	HeightAvg *float64 `json:"heightAvg"`
	WidthMin  *float64 `json:"widthMin"`
	WidthMax  *float64 `json:"widthMax"`
	WidthSum  *float64 `json:"widthSum"`
	WidthAvg  *float64 `json:"widthAvg"`
	DepthMin  *float64 `json:"depthMin"`
	DepthMax  *float64 `json:"depthMax"`
	DepthSum  *float64 `json:"depthSum"`
	DepthAvg  *float64 `json:"depthAvg"`
}

type BoundingBoxDimensionsFilter struct {
	ID  []string                          `json:"id,omitempty"`
	Has []*BoundingBoxDimensionsHasFilter `json:"has,omitempty"`
	And []*BoundingBoxDimensionsFilter    `json:"and,omitempty"`
	Or  []*BoundingBoxDimensionsFilter    `json:"or,omitempty"`
	Not *BoundingBoxDimensionsFilter      `json:"not,omitempty"`
}

type BoundingBoxDimensionsOrder struct {
	Asc  *BoundingBoxDimensionsOrderable `json:"asc,omitempty"`
	Desc *BoundingBoxDimensionsOrderable `json:"desc,omitempty"`
	Then *BoundingBoxDimensionsOrder     `json:"then,omitempty"`
}

type BoundingBoxDimensionsPatch struct {
	Height *float64 `json:"height,omitempty"`
	Width  *float64 `json:"width,omitempty"`
	Depth  *float64 `json:"depth,omitempty"`
}

type BoundingBoxDimensionsRef struct {
	ID     *string  `json:"id,omitempty"`
	Height *float64 `json:"height,omitempty"`
	Width  *float64 `json:"width,omitempty"`
	Depth  *float64 `json:"depth,omitempty"`
}

// A category is a classification of products.
type Category struct {
	ID string `json:"id"`
	// The human readable identifier of the category (lowercased fullName). For example: `hardware/cpu`
	Xid string `json:"xid"`
	// Full name of the category including the names of all parent categories. For example: `Hardware/CPU`.
	FullName string `json:"fullName"`
	// Name of this category. For example: `CPU`.
	Name string `json:"name"`
	// A short description of the category.
	Description *string `json:"description"`
	// The parent category of this category.
	Parent *Category `json:"parent"`
	// List of all subcategories of this category.
	Children []*Category `json:"children"`
	// List of all products, that are categorized under this category.
	Products          []*Product               `json:"products"`
	ChildrenAggregate *CategoryAggregateResult `json:"childrenAggregate"`
	ProductsAggregate *ProductAggregateResult  `json:"productsAggregate"`
}

func (Category) IsNode() {}

type CategoryAggregateResult struct {
	Count          *int64  `json:"count"`
	XidMin         *string `json:"xidMin"`
	XidMax         *string `json:"xidMax"`
	FullNameMin    *string `json:"fullNameMin"`
	FullNameMax    *string `json:"fullNameMax"`
	NameMin        *string `json:"nameMin"`
	NameMax        *string `json:"nameMax"`
	DescriptionMin *string `json:"descriptionMin"`
	DescriptionMax *string `json:"descriptionMax"`
}

type CategoryFilter struct {
	ID       []string                                `json:"id,omitempty"`
	Xid      *StringHashFilter                       `json:"xid,omitempty"`
	FullName *StringFullTextFilterStringRegExpFilter `json:"fullName,omitempty"`
	Name     *StringFullTextFilterStringRegExpFilter `json:"name,omitempty"`
	Has      []*CategoryHasFilter                    `json:"has,omitempty"`
	And      []*CategoryFilter                       `json:"and,omitempty"`
	Or       []*CategoryFilter                       `json:"or,omitempty"`
	Not      *CategoryFilter                         `json:"not,omitempty"`
}

type CategoryOrder struct {
	Asc  *CategoryOrderable `json:"asc,omitempty"`
	Desc *CategoryOrderable `json:"desc,omitempty"`
	Then *CategoryOrder     `json:"then,omitempty"`
}

type CategoryPatch struct {
	// The human readable identifier of the category (lowercased fullName). For example: `hardware/cpu`
	Xid *string `json:"xid,omitempty"`
	// Full name of the category including the names of all parent categories. For example: `Hardware/CPU`.
	FullName *string `json:"fullName,omitempty"`
	// Name of this category. For example: `CPU`.
	Name *string `json:"name,omitempty"`
	// A short description of the category.
	Description *string        `json:"description,omitempty"`
	Parent      *CategoryRef   `json:"parent,omitempty"`
	Children    []*CategoryRef `json:"children,omitempty"`
	Products    []*ProductRef  `json:"products,omitempty"`
}

type CategoryRef struct {
	ID *string `json:"id,omitempty"`
	// The human readable identifier of the category (lowercased fullName). For example: `hardware/cpu`
	Xid *string `json:"xid,omitempty"`
	// Full name of the category including the names of all parent categories. For example: `Hardware/CPU`.
	FullName *string `json:"fullName,omitempty"`
	// Name of this category. For example: `CPU`.
	Name *string `json:"name,omitempty"`
	// A short description of the category.
	Description *string        `json:"description,omitempty"`
	Parent      *CategoryRef   `json:"parent,omitempty"`
	Children    []*CategoryRef `json:"children,omitempty"`
	Products    []*ProductRef  `json:"products,omitempty"`
}

// A component is a tangible object that can be a module or a part. It has a name, a description, legal information, documentation and other information and can exist in multiple versions.
type Component struct {
	DiscoveredAt  time.Time  `json:"discoveredAt"`
	LastIndexedAt time.Time  `json:"lastIndexedAt"`
	DataSource    Repository `json:"dataSource"`
	ID            string     `json:"id"`
	//  The unique human readable identifier of the component in the format: `domain.tld/owner/repo/version/file-path/component-name`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml/baz`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-/baz`
	// - `oshwa.org/-/-/1.0.0/us000000.html/baz`
	Xid string `json:"xid"`
	// The name of the component.
	Name string `json:"name"`
	// The short description of the component.
	Description string `json:"description"`
	// The version string of the release.
	Version string `json:"version"`
	// The date and time when the release was created.
	CreatedAt time.Time `json:"createdAt"`
	// A list of all releases of the component.
	Releases []*Component `json:"releases"`
	// Indicates if this release is the latest release of the component.
	IsLatest bool `json:"isLatest"`
	// The repository that this component is developed in.
	Repository Repository `json:"repository"`
	// The license used for the component.
	License *License `json:"license"`
	// The additional licenses used for the documentation and other assets, if any.
	AdditionalLicenses []*License `json:"additionalLicenses"`
	// The license holder of the component.
	Licensor UserOrGroup `json:"licensor"`
	// The language in which the documentation is written.
	DocumentationLanguage string `json:"documentationLanguage"`
	// The OSH technology readiness level (OTRL) of the component. For information see:
	// https://github.com/OPEN-NEXT/OKH-LOSH/blob/master/OTRL.md
	TechnologyReadinessLevel TechnologyReadinessLevel `json:"technologyReadinessLevel"`
	// The OSH documentation readiness level (ODRL) of the component. For information see:
	// https://github.com/OPEN-NEXT/OKH-LOSH/blob/master/OTRL.md
	DocumentationReadinessLevel DocumentationReadinessLevel `json:"documentationReadinessLevel"`
	// The permanent URL to evidence of compliance (OSHWA, FSF, DIN SPEC 3105).
	Attestation *string `json:"attestation"`
	// The scientific publication (DOI) in which the component has been peer reviewed.
	Publication *string `json:"publication"`
	Issues      *string `json:"issues"`
	// The technical standard that the component complies with.
	CompliesWith *TechnicalStandard `json:"compliesWith"`
	// The international patent classification (IPC) of the component.
	CpcPatentClass *string `json:"cpcPatentClass"`
	// The identifier for the applying "Technology-specific Documentation Criteria"
	// according to DIN SPEC 3105-1. For example: `3DP`
	// See: https://gitlab.com/OSEGermany/oh-tsdc/-/blob/master/OH-TsDC.md
	Tsdc *TechnologySpecificDocumentationCriteria `json:"tsdc"`
	// A list of sub components.
	Components []*Component `json:"components"`
	// A list of software (including firmware) that is reuqired to run and use the component.
	Software []*Software `json:"software"`
	// An image of the component if any is available.
	Image *File `json:"image"`
	// A readme document of the component if any is available.
	Readme *File `json:"readme"`
	// A contribution guide document of the component if any is available.
	ContributionGuide *File `json:"contributionGuide"`
	// A bill of materials document of the component if any is available.
	Bom *File `json:"bom"`
	// A manufacturing instructions document of the component if any is available.
	ManufacturingInstructions *File `json:"manufacturingInstructions"`
	// An user manual document of the component if any is available.
	UserManual *File `json:"userManual"`
	// The product this component belongs to.
	Product *Product `json:"product"`
	// A list of components that use this component.
	UsedIn []*Component `json:"usedIn"`
	// The source file that makes the component.
	Source *File `json:"source"`
	// A list of files exported from the source file.
	Export []*File `json:"export"`
	// A list of auxiliary files.
	Auxiliary    []*File `json:"auxiliary"`
	Organization *Group  `json:"organization"`
	// The mass of the component in grams.
	Mass *float64 `json:"mass"`
	// The outer dimensions of the component.
	OuterDimensions OuterDimensions `json:"outerDimensions"`
	// The material the part is made of. Components do not have a material.
	Material *Material `json:"material"`
	// The process used to produce the component.
	ManufacturingProcess *ManufacturingProcess `json:"manufacturingProcess"`
	// A list of additional production metadata such as tolerances, surface roughness, etc.
	ProductionMetadata          []*KeyValue               `json:"productionMetadata"`
	ReleasesAggregate           *ComponentAggregateResult `json:"releasesAggregate"`
	AdditionalLicensesAggregate *LicenseAggregateResult   `json:"additionalLicensesAggregate"`
	ComponentsAggregate         *ComponentAggregateResult `json:"componentsAggregate"`
	SoftwareAggregate           *SoftwareAggregateResult  `json:"softwareAggregate"`
	UsedInAggregate             *ComponentAggregateResult `json:"usedInAggregate"`
	ExportAggregate             *FileAggregateResult      `json:"exportAggregate"`
	AuxiliaryAggregate          *FileAggregateResult      `json:"auxiliaryAggregate"`
	ProductionMetadataAggregate *KeyValueAggregateResult  `json:"productionMetadataAggregate"`
}

func (Component) IsNode()        {}
func (Component) IsCrawlerMeta() {}

type ComponentAggregateResult struct {
	Count                    *int64     `json:"count"`
	DiscoveredAtMin          *time.Time `json:"discoveredAtMin"`
	DiscoveredAtMax          *time.Time `json:"discoveredAtMax"`
	LastIndexedAtMin         *time.Time `json:"lastIndexedAtMin"`
	LastIndexedAtMax         *time.Time `json:"lastIndexedAtMax"`
	XidMin                   *string    `json:"xidMin"`
	XidMax                   *string    `json:"xidMax"`
	NameMin                  *string    `json:"nameMin"`
	NameMax                  *string    `json:"nameMax"`
	DescriptionMin           *string    `json:"descriptionMin"`
	DescriptionMax           *string    `json:"descriptionMax"`
	VersionMin               *string    `json:"versionMin"`
	VersionMax               *string    `json:"versionMax"`
	CreatedAtMin             *time.Time `json:"createdAtMin"`
	CreatedAtMax             *time.Time `json:"createdAtMax"`
	DocumentationLanguageMin *string    `json:"documentationLanguageMin"`
	DocumentationLanguageMax *string    `json:"documentationLanguageMax"`
	AttestationMin           *string    `json:"attestationMin"`
	AttestationMax           *string    `json:"attestationMax"`
	PublicationMin           *string    `json:"publicationMin"`
	PublicationMax           *string    `json:"publicationMax"`
	IssuesMin                *string    `json:"issuesMin"`
	IssuesMax                *string    `json:"issuesMax"`
	CpcPatentClassMin        *string    `json:"cpcPatentClassMin"`
	CpcPatentClassMax        *string    `json:"cpcPatentClassMax"`
	MassMin                  *float64   `json:"massMin"`
	MassMax                  *float64   `json:"massMax"`
	MassSum                  *float64   `json:"massSum"`
	MassAvg                  *float64   `json:"massAvg"`
}

type ComponentFilter struct {
	DiscoveredAt          *DateTimeFilter                                         `json:"discoveredAt,omitempty"`
	LastIndexedAt         *DateTimeFilter                                         `json:"lastIndexedAt,omitempty"`
	ID                    []string                                                `json:"id,omitempty"`
	Xid                   *StringHashFilter                                       `json:"xid,omitempty"`
	Name                  *StringFullTextFilterStringHashFilterStringRegExpFilter `json:"name,omitempty"`
	Description           *StringFullTextFilterStringRegExpFilter                 `json:"description,omitempty"`
	Version               *StringTermFilter                                       `json:"version,omitempty"`
	CreatedAt             *DateTimeFilter                                         `json:"createdAt,omitempty"`
	IsLatest              *bool                                                   `json:"isLatest,omitempty"`
	DocumentationLanguage *StringHashFilter                                       `json:"documentationLanguage,omitempty"`
	Attestation           *StringHashFilter                                       `json:"attestation,omitempty"`
	Publication           *StringHashFilter                                       `json:"publication,omitempty"`
	Issues                *StringHashFilter                                       `json:"issues,omitempty"`
	CpcPatentClass        *StringHashFilter                                       `json:"cpcPatentClass,omitempty"`
	Mass                  *FloatFilter                                            `json:"mass,omitempty"`
	Has                   []*ComponentHasFilter                                   `json:"has,omitempty"`
	And                   []*ComponentFilter                                      `json:"and,omitempty"`
	Or                    []*ComponentFilter                                      `json:"or,omitempty"`
	Not                   *ComponentFilter                                        `json:"not,omitempty"`
}

type ComponentOrder struct {
	Asc  *ComponentOrderable `json:"asc,omitempty"`
	Desc *ComponentOrderable `json:"desc,omitempty"`
	Then *ComponentOrder     `json:"then,omitempty"`
}

type ComponentPatch struct {
	DiscoveredAt  *time.Time     `json:"discoveredAt,omitempty"`
	LastIndexedAt *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource    *RepositoryRef `json:"dataSource,omitempty"`
	//  The unique human readable identifier of the component in the format: `domain.tld/owner/repo/version/file-path/component-name`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml/baz`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-/baz`
	// - `oshwa.org/-/-/1.0.0/us000000.html/baz`
	Xid *string `json:"xid,omitempty"`
	// The name of the component.
	Name *string `json:"name,omitempty"`
	// The short description of the component.
	Description *string `json:"description,omitempty"`
	// The version string of the release.
	Version *string `json:"version,omitempty"`
	// The date and time when the release was created.
	CreatedAt *time.Time      `json:"createdAt,omitempty"`
	Releases  []*ComponentRef `json:"releases,omitempty"`
	// Indicates if this release is the latest release of the component.
	IsLatest           *bool           `json:"isLatest,omitempty"`
	Repository         *RepositoryRef  `json:"repository,omitempty"`
	License            *LicenseRef     `json:"license,omitempty"`
	AdditionalLicenses []*LicenseRef   `json:"additionalLicenses,omitempty"`
	Licensor           *UserOrGroupRef `json:"licensor,omitempty"`
	// The language in which the documentation is written.
	DocumentationLanguage *string `json:"documentationLanguage,omitempty"`
	// The OSH technology readiness level (OTRL) of the component. For information see:
	// https://github.com/OPEN-NEXT/OKH-LOSH/blob/master/OTRL.md
	TechnologyReadinessLevel *TechnologyReadinessLevel `json:"technologyReadinessLevel,omitempty"`
	// The OSH documentation readiness level (ODRL) of the component. For information see:
	// https://github.com/OPEN-NEXT/OKH-LOSH/blob/master/OTRL.md
	DocumentationReadinessLevel *DocumentationReadinessLevel `json:"documentationReadinessLevel,omitempty"`
	// The permanent URL to evidence of compliance (OSHWA, FSF, DIN SPEC 3105).
	Attestation *string `json:"attestation,omitempty"`
	// The scientific publication (DOI) in which the component has been peer reviewed.
	Publication  *string               `json:"publication,omitempty"`
	Issues       *string               `json:"issues,omitempty"`
	CompliesWith *TechnicalStandardRef `json:"compliesWith,omitempty"`
	// The international patent classification (IPC) of the component.
	CpcPatentClass            *string                                     `json:"cpcPatentClass,omitempty"`
	Tsdc                      *TechnologySpecificDocumentationCriteriaRef `json:"tsdc,omitempty"`
	Components                []*ComponentRef                             `json:"components,omitempty"`
	Software                  []*SoftwareRef                              `json:"software,omitempty"`
	Image                     *FileRef                                    `json:"image,omitempty"`
	Readme                    *FileRef                                    `json:"readme,omitempty"`
	ContributionGuide         *FileRef                                    `json:"contributionGuide,omitempty"`
	Bom                       *FileRef                                    `json:"bom,omitempty"`
	ManufacturingInstructions *FileRef                                    `json:"manufacturingInstructions,omitempty"`
	UserManual                *FileRef                                    `json:"userManual,omitempty"`
	Product                   *ProductRef                                 `json:"product,omitempty"`
	UsedIn                    []*ComponentRef                             `json:"usedIn,omitempty"`
	Source                    *FileRef                                    `json:"source,omitempty"`
	Export                    []*FileRef                                  `json:"export,omitempty"`
	Auxiliary                 []*FileRef                                  `json:"auxiliary,omitempty"`
	Organization              *GroupRef                                   `json:"organization,omitempty"`
	// The mass of the component in grams.
	Mass                 *float64                 `json:"mass,omitempty"`
	OuterDimensions      *OuterDimensionsRef      `json:"outerDimensions,omitempty"`
	Material             *MaterialRef             `json:"material,omitempty"`
	ManufacturingProcess *ManufacturingProcessRef `json:"manufacturingProcess,omitempty"`
	ProductionMetadata   []*KeyValueRef           `json:"productionMetadata,omitempty"`
}

type ComponentRef struct {
	ID            *string        `json:"id,omitempty"`
	DiscoveredAt  *time.Time     `json:"discoveredAt,omitempty"`
	LastIndexedAt *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource    *RepositoryRef `json:"dataSource,omitempty"`
	//  The unique human readable identifier of the component in the format: `domain.tld/owner/repo/version/file-path/component-name`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml/baz`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-/baz`
	// - `oshwa.org/-/-/1.0.0/us000000.html/baz`
	Xid *string `json:"xid,omitempty"`
	// The name of the component.
	Name *string `json:"name,omitempty"`
	// The short description of the component.
	Description *string `json:"description,omitempty"`
	// The version string of the release.
	Version *string `json:"version,omitempty"`
	// The date and time when the release was created.
	CreatedAt *time.Time      `json:"createdAt,omitempty"`
	Releases  []*ComponentRef `json:"releases,omitempty"`
	// Indicates if this release is the latest release of the component.
	IsLatest           *bool           `json:"isLatest,omitempty"`
	Repository         *RepositoryRef  `json:"repository,omitempty"`
	License            *LicenseRef     `json:"license,omitempty"`
	AdditionalLicenses []*LicenseRef   `json:"additionalLicenses,omitempty"`
	Licensor           *UserOrGroupRef `json:"licensor,omitempty"`
	// The language in which the documentation is written.
	DocumentationLanguage *string `json:"documentationLanguage,omitempty"`
	// The OSH technology readiness level (OTRL) of the component. For information see:
	// https://github.com/OPEN-NEXT/OKH-LOSH/blob/master/OTRL.md
	TechnologyReadinessLevel *TechnologyReadinessLevel `json:"technologyReadinessLevel,omitempty"`
	// The OSH documentation readiness level (ODRL) of the component. For information see:
	// https://github.com/OPEN-NEXT/OKH-LOSH/blob/master/OTRL.md
	DocumentationReadinessLevel *DocumentationReadinessLevel `json:"documentationReadinessLevel,omitempty"`
	// The permanent URL to evidence of compliance (OSHWA, FSF, DIN SPEC 3105).
	Attestation *string `json:"attestation,omitempty"`
	// The scientific publication (DOI) in which the component has been peer reviewed.
	Publication  *string               `json:"publication,omitempty"`
	Issues       *string               `json:"issues,omitempty"`
	CompliesWith *TechnicalStandardRef `json:"compliesWith,omitempty"`
	// The international patent classification (IPC) of the component.
	CpcPatentClass            *string                                     `json:"cpcPatentClass,omitempty"`
	Tsdc                      *TechnologySpecificDocumentationCriteriaRef `json:"tsdc,omitempty"`
	Components                []*ComponentRef                             `json:"components,omitempty"`
	Software                  []*SoftwareRef                              `json:"software,omitempty"`
	Image                     *FileRef                                    `json:"image,omitempty"`
	Readme                    *FileRef                                    `json:"readme,omitempty"`
	ContributionGuide         *FileRef                                    `json:"contributionGuide,omitempty"`
	Bom                       *FileRef                                    `json:"bom,omitempty"`
	ManufacturingInstructions *FileRef                                    `json:"manufacturingInstructions,omitempty"`
	UserManual                *FileRef                                    `json:"userManual,omitempty"`
	Product                   *ProductRef                                 `json:"product,omitempty"`
	UsedIn                    []*ComponentRef                             `json:"usedIn,omitempty"`
	Source                    *FileRef                                    `json:"source,omitempty"`
	Export                    []*FileRef                                  `json:"export,omitempty"`
	Auxiliary                 []*FileRef                                  `json:"auxiliary,omitempty"`
	Organization              *GroupRef                                   `json:"organization,omitempty"`
	// The mass of the component in grams.
	Mass                 *float64                 `json:"mass,omitempty"`
	OuterDimensions      *OuterDimensionsRef      `json:"outerDimensions,omitempty"`
	Material             *MaterialRef             `json:"material,omitempty"`
	ManufacturingProcess *ManufacturingProcessRef `json:"manufacturingProcess,omitempty"`
	ProductionMetadata   []*KeyValueRef           `json:"productionMetadata,omitempty"`
}

type ContainsFilter struct {
	Point   *PointRef   `json:"point,omitempty"`
	Polygon *PolygonRef `json:"polygon,omitempty"`
}

type CrawlerMetaAggregateResult struct {
	Count            *int64     `json:"count"`
	DiscoveredAtMin  *time.Time `json:"discoveredAtMin"`
	DiscoveredAtMax  *time.Time `json:"discoveredAtMax"`
	LastIndexedAtMin *time.Time `json:"lastIndexedAtMin"`
	LastIndexedAtMax *time.Time `json:"lastIndexedAtMax"`
}

type CrawlerMetaFilter struct {
	DiscoveredAt  *DateTimeFilter         `json:"discoveredAt,omitempty"`
	LastIndexedAt *DateTimeFilter         `json:"lastIndexedAt,omitempty"`
	Has           []*CrawlerMetaHasFilter `json:"has,omitempty"`
	And           []*CrawlerMetaFilter    `json:"and,omitempty"`
	Or            []*CrawlerMetaFilter    `json:"or,omitempty"`
	Not           *CrawlerMetaFilter      `json:"not,omitempty"`
}

type CrawlerMetaOrder struct {
	Asc  *CrawlerMetaOrderable `json:"asc,omitempty"`
	Desc *CrawlerMetaOrderable `json:"desc,omitempty"`
	Then *CrawlerMetaOrder     `json:"then,omitempty"`
}

type CrawlerMetaPatch struct {
	// The date and time the object was discovered by the crawler.
	DiscoveredAt *time.Time `json:"discoveredAt,omitempty"`
	// The date and time the object was last visited and indexed by the crawler.
	LastIndexedAt *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource    *RepositoryRef `json:"dataSource,omitempty"`
}

type CustomHTTP struct {
	URL                  string     `json:"url"`
	Method               HTTPMethod `json:"method"`
	Body                 *string    `json:"body,omitempty"`
	Graphql              *string    `json:"graphql,omitempty"`
	Mode                 *Mode      `json:"mode,omitempty"`
	ForwardHeaders       []string   `json:"forwardHeaders,omitempty"`
	SecretHeaders        []string   `json:"secretHeaders,omitempty"`
	IntrospectionHeaders []string   `json:"introspectionHeaders,omitempty"`
	SkipIntrospection    *bool      `json:"skipIntrospection,omitempty"`
}

// Meta data concerning the database itself.
type Database struct {
	ID string `json:"id"`
	// The version of the database schema.
	Version string `json:"version"`
}

func (Database) IsNode() {}

type DatabaseAggregateResult struct {
	Count      *int64  `json:"count"`
	VersionMin *string `json:"versionMin"`
	VersionMax *string `json:"versionMax"`
}

type DatabaseFilter struct {
	ID  []string             `json:"id,omitempty"`
	Has []*DatabaseHasFilter `json:"has,omitempty"`
	And []*DatabaseFilter    `json:"and,omitempty"`
	Or  []*DatabaseFilter    `json:"or,omitempty"`
	Not *DatabaseFilter      `json:"not,omitempty"`
}

type DatabaseOrder struct {
	Asc  *DatabaseOrderable `json:"asc,omitempty"`
	Desc *DatabaseOrderable `json:"desc,omitempty"`
	Then *DatabaseOrder     `json:"then,omitempty"`
}

type DatabasePatch struct {
	// The version of the database schema.
	Version *string `json:"version,omitempty"`
}

type DatabaseRef struct {
	ID *string `json:"id,omitempty"`
	// The version of the database schema.
	Version *string `json:"version,omitempty"`
}

type DateTimeFilter struct {
	Eq      *time.Time     `json:"eq,omitempty"`
	In      []*time.Time   `json:"in,omitempty"`
	Le      *time.Time     `json:"le,omitempty"`
	Lt      *time.Time     `json:"lt,omitempty"`
	Ge      *time.Time     `json:"ge,omitempty"`
	Gt      *time.Time     `json:"gt,omitempty"`
	Between *DateTimeRange `json:"between,omitempty"`
}

type DateTimeRange struct {
	Min time.Time `json:"min"`
	Max time.Time `json:"max"`
}

type DeleteBoundingBoxDimensionsPayload struct {
	BoundingBoxDimensions []*BoundingBoxDimensions `json:"boundingBoxDimensions"`
	Msg                   *string                  `json:"msg"`
	NumUids               *int64                   `json:"numUids"`
}

type DeleteCategoryPayload struct {
	Category []*Category `json:"category"`
	Msg      *string     `json:"msg"`
	NumUids  *int64      `json:"numUids"`
}

type DeleteComponentPayload struct {
	Component []*Component `json:"component"`
	Msg       *string      `json:"msg"`
	NumUids   *int64       `json:"numUids"`
}

type DeleteCrawlerMetaPayload struct {
	CrawlerMeta []CrawlerMeta `json:"crawlerMeta"`
	Msg         *string       `json:"msg"`
	NumUids     *int64        `json:"numUids"`
}

type DeleteDatabasePayload struct {
	Database []*Database `json:"database"`
	Msg      *string     `json:"msg"`
	NumUids  *int64      `json:"numUids"`
}

type DeleteFilePayload struct {
	File    []*File `json:"file"`
	Msg     *string `json:"msg"`
	NumUids *int64  `json:"numUids"`
}

type DeleteFloatVPayload struct {
	FloatV  []*FloatV `json:"floatV"`
	Msg     *string   `json:"msg"`
	NumUids *int64    `json:"numUids"`
}

type DeleteGroupPayload struct {
	Group   []*Group `json:"group"`
	Msg     *string  `json:"msg"`
	NumUids *int64   `json:"numUids"`
}

type DeleteHostPayload struct {
	Host    []*Host `json:"host"`
	Msg     *string `json:"msg"`
	NumUids *int64  `json:"numUids"`
}

type DeleteKeyValuePayload struct {
	KeyValue []*KeyValue `json:"keyValue"`
	Msg      *string     `json:"msg"`
	NumUids  *int64      `json:"numUids"`
}

type DeleteLicensePayload struct {
	License []*License `json:"license"`
	Msg     *string    `json:"msg"`
	NumUids *int64     `json:"numUids"`
}

type DeleteManufacturingProcessPayload struct {
	ManufacturingProcess []*ManufacturingProcess `json:"manufacturingProcess"`
	Msg                  *string                 `json:"msg"`
	NumUids              *int64                  `json:"numUids"`
}

type DeleteMaterialPayload struct {
	Material []*Material `json:"material"`
	Msg      *string     `json:"msg"`
	NumUids  *int64      `json:"numUids"`
}

type DeleteNodePayload struct {
	Node    []Node  `json:"node"`
	Msg     *string `json:"msg"`
	NumUids *int64  `json:"numUids"`
}

type DeleteOpenSCADDimensionsPayload struct {
	OpenSCADDimensions []*OpenSCADDimensions `json:"openSCADDimensions"`
	Msg                *string               `json:"msg"`
	NumUids            *int64                `json:"numUids"`
}

type DeleteProductPayload struct {
	Product []*Product `json:"product"`
	Msg     *string    `json:"msg"`
	NumUids *int64     `json:"numUids"`
}

type DeleteRepositoryPayload struct {
	Repository []*Repository `json:"repository"`
	Msg        *string       `json:"msg"`
	NumUids    *int64        `json:"numUids"`
}

type DeleteSoftwarePayload struct {
	Software []*Software `json:"software"`
	Msg      *string     `json:"msg"`
	NumUids  *int64      `json:"numUids"`
}

type DeleteStringVPayload struct {
	StringV []*StringV `json:"stringV"`
	Msg     *string    `json:"msg"`
	NumUids *int64     `json:"numUids"`
}

type DeleteTagPayload struct {
	Tag     []*Tag  `json:"tag"`
	Msg     *string `json:"msg"`
	NumUids *int64  `json:"numUids"`
}

type DeleteTechnicalStandardPayload struct {
	TechnicalStandard []*TechnicalStandard `json:"technicalStandard"`
	Msg               *string              `json:"msg"`
	NumUids           *int64               `json:"numUids"`
}

type DeleteTechnologySpecificDocumentationCriteriaPayload struct {
	TechnologySpecificDocumentationCriteria []*TechnologySpecificDocumentationCriteria `json:"technologySpecificDocumentationCriteria"`
	Msg                                     *string                                    `json:"msg"`
	NumUids                                 *int64                                     `json:"numUids"`
}

type DeleteUserOrGroupPayload struct {
	UserOrGroup []UserOrGroup `json:"userOrGroup"`
	Msg         *string       `json:"msg"`
	NumUids     *int64        `json:"numUids"`
}

type DeleteUserPayload struct {
	User    []*User `json:"user"`
	Msg     *string `json:"msg"`
	NumUids *int64  `json:"numUids"`
}

type DgraphDefault struct {
	Value *string `json:"value,omitempty"`
}

type File struct {
	DiscoveredAt  time.Time  `json:"discoveredAt"`
	LastIndexedAt time.Time  `json:"lastIndexedAt"`
	DataSource    Repository `json:"dataSource"`
	ID            string     `json:"id"`
	// The unique human readable identifier of the file in the format: `domain.tld/owner/repo/ref/file-path`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-`
	// - `oshwa.org/-/-/1.0.0/us000000.html`
	Xid string `json:"xid"`
	// The name of the file (without parent path).
	Name string `json:"name"`
	// The path of the file within the repository.
	Path string `json:"path"`
	// The mimetype of the file.
	MimeType *string `json:"mimeType"`
	// The download URL of the file.
	URL string `json:"url"`
	// The date and time when the file was created.
	CreatedAt *time.Time `json:"createdAt"`
}

func (File) IsNode()        {}
func (File) IsCrawlerMeta() {}

type FileAggregateResult struct {
	Count            *int64     `json:"count"`
	DiscoveredAtMin  *time.Time `json:"discoveredAtMin"`
	DiscoveredAtMax  *time.Time `json:"discoveredAtMax"`
	LastIndexedAtMin *time.Time `json:"lastIndexedAtMin"`
	LastIndexedAtMax *time.Time `json:"lastIndexedAtMax"`
	XidMin           *string    `json:"xidMin"`
	XidMax           *string    `json:"xidMax"`
	NameMin          *string    `json:"nameMin"`
	NameMax          *string    `json:"nameMax"`
	PathMin          *string    `json:"pathMin"`
	PathMax          *string    `json:"pathMax"`
	MimeTypeMin      *string    `json:"mimeTypeMin"`
	MimeTypeMax      *string    `json:"mimeTypeMax"`
	URLMin           *string    `json:"urlMin"`
	URLMax           *string    `json:"urlMax"`
	CreatedAtMin     *time.Time `json:"createdAtMin"`
	CreatedAtMax     *time.Time `json:"createdAtMax"`
}

type FileFilter struct {
	DiscoveredAt  *DateTimeFilter                                         `json:"discoveredAt,omitempty"`
	LastIndexedAt *DateTimeFilter                                         `json:"lastIndexedAt,omitempty"`
	ID            []string                                                `json:"id,omitempty"`
	Xid           *StringHashFilter                                       `json:"xid,omitempty"`
	Name          *StringFullTextFilterStringHashFilterStringRegExpFilter `json:"name,omitempty"`
	Path          *StringFullTextFilterStringHashFilterStringRegExpFilter `json:"path,omitempty"`
	MimeType      *StringHashFilter                                       `json:"mimeType,omitempty"`
	CreatedAt     *DateTimeFilter                                         `json:"createdAt,omitempty"`
	Has           []*FileHasFilter                                        `json:"has,omitempty"`
	And           []*FileFilter                                           `json:"and,omitempty"`
	Or            []*FileFilter                                           `json:"or,omitempty"`
	Not           *FileFilter                                             `json:"not,omitempty"`
}

type FileOrder struct {
	Asc  *FileOrderable `json:"asc,omitempty"`
	Desc *FileOrderable `json:"desc,omitempty"`
	Then *FileOrder     `json:"then,omitempty"`
}

type FilePatch struct {
	DiscoveredAt  *time.Time     `json:"discoveredAt,omitempty"`
	LastIndexedAt *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource    *RepositoryRef `json:"dataSource,omitempty"`
	// The unique human readable identifier of the file in the format: `domain.tld/owner/repo/ref/file-path`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-`
	// - `oshwa.org/-/-/1.0.0/us000000.html`
	Xid *string `json:"xid,omitempty"`
	// The name of the file (without parent path).
	Name *string `json:"name,omitempty"`
	// The path of the file within the repository.
	Path *string `json:"path,omitempty"`
	// The mimetype of the file.
	MimeType *string `json:"mimeType,omitempty"`
	// The download URL of the file.
	URL *string `json:"url,omitempty"`
	// The date and time when the file was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`
}

type FileRef struct {
	ID            *string        `json:"id,omitempty"`
	DiscoveredAt  *time.Time     `json:"discoveredAt,omitempty"`
	LastIndexedAt *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource    *RepositoryRef `json:"dataSource,omitempty"`
	// The unique human readable identifier of the file in the format: `domain.tld/owner/repo/ref/file-path`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-`
	// - `oshwa.org/-/-/1.0.0/us000000.html`
	Xid *string `json:"xid,omitempty"`
	// The name of the file (without parent path).
	Name *string `json:"name,omitempty"`
	// The path of the file within the repository.
	Path *string `json:"path,omitempty"`
	// The mimetype of the file.
	MimeType *string `json:"mimeType,omitempty"`
	// The download URL of the file.
	URL *string `json:"url,omitempty"`
	// The date and time when the file was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`
}

type FloatFilter struct {
	Eq      *float64    `json:"eq,omitempty"`
	In      []*float64  `json:"in,omitempty"`
	Le      *float64    `json:"le,omitempty"`
	Lt      *float64    `json:"lt,omitempty"`
	Ge      *float64    `json:"ge,omitempty"`
	Gt      *float64    `json:"gt,omitempty"`
	Between *FloatRange `json:"between,omitempty"`
}

type FloatRange struct {
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type FloatV struct {
	ID    string  `json:"id"`
	Value float64 `json:"value"`
}

func (FloatV) IsStringOrFloat() {}
func (FloatV) IsNode()          {}

type FloatVAggregateResult struct {
	Count    *int64   `json:"count"`
	ValueMin *float64 `json:"valueMin"`
	ValueMax *float64 `json:"valueMax"`
	ValueSum *float64 `json:"valueSum"`
	ValueAvg *float64 `json:"valueAvg"`
}

type FloatVFilter struct {
	ID  []string           `json:"id,omitempty"`
	Has []*FloatVHasFilter `json:"has,omitempty"`
	And []*FloatVFilter    `json:"and,omitempty"`
	Or  []*FloatVFilter    `json:"or,omitempty"`
	Not *FloatVFilter      `json:"not,omitempty"`
}

type FloatVOrder struct {
	Asc  *FloatVOrderable `json:"asc,omitempty"`
	Desc *FloatVOrderable `json:"desc,omitempty"`
	Then *FloatVOrder     `json:"then,omitempty"`
}

type FloatVPatch struct {
	Value *float64 `json:"value,omitempty"`
}

type FloatVRef struct {
	ID    *string  `json:"id,omitempty"`
	Value *float64 `json:"value,omitempty"`
}

type GenerateMutationParams struct {
	Add    *bool `json:"add,omitempty"`
	Update *bool `json:"update,omitempty"`
	Delete *bool `json:"delete,omitempty"`
}

type GenerateQueryParams struct {
	Get       *bool `json:"get,omitempty"`
	Query     *bool `json:"query,omitempty"`
	Password  *bool `json:"password,omitempty"`
	Aggregate *bool `json:"aggregate,omitempty"`
}

type Group struct {
	Xid      string     `json:"xid"`
	Host     Host       `json:"host"`
	Name     string     `json:"name"`
	FullName *string    `json:"fullName"`
	Email    *string    `json:"email"`
	Avatar   *File      `json:"avatar"`
	URL      *string    `json:"url"`
	MemberOf []*Group   `json:"memberOf"`
	Products []*Product `json:"products"`
	ID       string     `json:"id"`
	// Members of the group.
	Members           []UserOrGroup               `json:"members"`
	MemberOfAggregate *GroupAggregateResult       `json:"memberOfAggregate"`
	ProductsAggregate *ProductAggregateResult     `json:"productsAggregate"`
	MembersAggregate  *UserOrGroupAggregateResult `json:"membersAggregate"`
}

func (Group) IsNode()        {}
func (Group) IsUserOrGroup() {}

type GroupAggregateResult struct {
	Count       *int64  `json:"count"`
	XidMin      *string `json:"xidMin"`
	XidMax      *string `json:"xidMax"`
	NameMin     *string `json:"nameMin"`
	NameMax     *string `json:"nameMax"`
	FullNameMin *string `json:"fullNameMin"`
	FullNameMax *string `json:"fullNameMax"`
	EmailMin    *string `json:"emailMin"`
	EmailMax    *string `json:"emailMax"`
	URLMin      *string `json:"urlMin"`
	URLMax      *string `json:"urlMax"`
}

type GroupFilter struct {
	Xid      *StringHashFilter                   `json:"xid,omitempty"`
	Name     *StringRegExpFilterStringTermFilter `json:"name,omitempty"`
	FullName *StringRegExpFilterStringTermFilter `json:"fullName,omitempty"`
	Email    *StringRegExpFilterStringTermFilter `json:"email,omitempty"`
	ID       []string                            `json:"id,omitempty"`
	Has      []*GroupHasFilter                   `json:"has,omitempty"`
	And      []*GroupFilter                      `json:"and,omitempty"`
	Or       []*GroupFilter                      `json:"or,omitempty"`
	Not      *GroupFilter                        `json:"not,omitempty"`
}

type GroupOrder struct {
	Asc  *GroupOrderable `json:"asc,omitempty"`
	Desc *GroupOrderable `json:"desc,omitempty"`
	Then *GroupOrder     `json:"then,omitempty"`
}

type GroupPatch struct {
	Xid      *string           `json:"xid,omitempty"`
	Host     *HostRef          `json:"host,omitempty"`
	Name     *string           `json:"name,omitempty"`
	FullName *string           `json:"fullName,omitempty"`
	Email    *string           `json:"email,omitempty"`
	Avatar   *FileRef          `json:"avatar,omitempty"`
	URL      *string           `json:"url,omitempty"`
	MemberOf []*GroupRef       `json:"memberOf,omitempty"`
	Products []*ProductRef     `json:"products,omitempty"`
	Members  []*UserOrGroupRef `json:"members,omitempty"`
}

type GroupRef struct {
	ID       *string           `json:"id,omitempty"`
	Xid      *string           `json:"xid,omitempty"`
	Host     *HostRef          `json:"host,omitempty"`
	Name     *string           `json:"name,omitempty"`
	FullName *string           `json:"fullName,omitempty"`
	Email    *string           `json:"email,omitempty"`
	Avatar   *FileRef          `json:"avatar,omitempty"`
	URL      *string           `json:"url,omitempty"`
	MemberOf []*GroupRef       `json:"memberOf,omitempty"`
	Products []*ProductRef     `json:"products,omitempty"`
	Members  []*UserOrGroupRef `json:"members,omitempty"`
}

// A host is a platform that is accessible over the network.
type Host struct {
	ID string `json:"id"`
	// The domain name of the host.
	Domain string `json:"domain"`
	// The nice name of the host.
	Name string `json:"name"`
}

func (Host) IsNode() {}

type HostAggregateResult struct {
	Count     *int64  `json:"count"`
	DomainMin *string `json:"domainMin"`
	DomainMax *string `json:"domainMax"`
	NameMin   *string `json:"nameMin"`
	NameMax   *string `json:"nameMax"`
}

type HostFilter struct {
	ID     []string                                            `json:"id,omitempty"`
	Domain *StringHashFilterStringRegExpFilter                 `json:"domain,omitempty"`
	Name   *StringHashFilterStringRegExpFilterStringTermFilter `json:"name,omitempty"`
	Has    []*HostHasFilter                                    `json:"has,omitempty"`
	And    []*HostFilter                                       `json:"and,omitempty"`
	Or     []*HostFilter                                       `json:"or,omitempty"`
	Not    *HostFilter                                         `json:"not,omitempty"`
}

type HostOrder struct {
	Asc  *HostOrderable `json:"asc,omitempty"`
	Desc *HostOrderable `json:"desc,omitempty"`
	Then *HostOrder     `json:"then,omitempty"`
}

type HostPatch struct {
	// The domain name of the host.
	Domain *string `json:"domain,omitempty"`
	// The nice name of the host.
	Name *string `json:"name,omitempty"`
}

type HostRef struct {
	ID *string `json:"id,omitempty"`
	// The domain name of the host.
	Domain *string `json:"domain,omitempty"`
	// The nice name of the host.
	Name *string `json:"name,omitempty"`
}

type Int64Filter struct {
	Eq      *string     `json:"eq,omitempty"`
	In      []*string   `json:"in,omitempty"`
	Le      *string     `json:"le,omitempty"`
	Lt      *string     `json:"lt,omitempty"`
	Ge      *string     `json:"ge,omitempty"`
	Gt      *string     `json:"gt,omitempty"`
	Between *Int64Range `json:"between,omitempty"`
}

type Int64Range struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type IntFilter struct {
	Eq      *int64    `json:"eq,omitempty"`
	In      []*int64  `json:"in,omitempty"`
	Le      *int64    `json:"le,omitempty"`
	Lt      *int64    `json:"lt,omitempty"`
	Ge      *int64    `json:"ge,omitempty"`
	Gt      *int64    `json:"gt,omitempty"`
	Between *IntRange `json:"between,omitempty"`
}

type IntRange struct {
	Min int64 `json:"min"`
	Max int64 `json:"max"`
}

type IntersectsFilter struct {
	Polygon      *PolygonRef      `json:"polygon,omitempty"`
	MultiPolygon *MultiPolygonRef `json:"multiPolygon,omitempty"`
}

type KeyValue struct {
	ID    string        `json:"id"`
	Key   string        `json:"key"`
	Value StringOrFloat `json:"value"`
}

func (KeyValue) IsNode() {}

type KeyValueAggregateResult struct {
	Count  *int64  `json:"count"`
	KeyMin *string `json:"keyMin"`
	KeyMax *string `json:"keyMax"`
}

type KeyValueFilter struct {
	ID  []string             `json:"id,omitempty"`
	Has []*KeyValueHasFilter `json:"has,omitempty"`
	And []*KeyValueFilter    `json:"and,omitempty"`
	Or  []*KeyValueFilter    `json:"or,omitempty"`
	Not *KeyValueFilter      `json:"not,omitempty"`
}

type KeyValueOrder struct {
	Asc  *KeyValueOrderable `json:"asc,omitempty"`
	Desc *KeyValueOrderable `json:"desc,omitempty"`
	Then *KeyValueOrder     `json:"then,omitempty"`
}

type KeyValuePatch struct {
	Key   *string           `json:"key,omitempty"`
	Value *StringOrFloatRef `json:"value,omitempty"`
}

type KeyValueRef struct {
	ID    *string           `json:"id,omitempty"`
	Key   *string           `json:"key,omitempty"`
	Value *StringOrFloatRef `json:"value,omitempty"`
}

// A license is a legal document that is used to protect the rights of a product.
type License struct {
	ID string `json:"id"`
	// The human readable ID of the license. If the license is a SPDX license, the ID is the SPDX ID.
	Xid string `json:"xid"`
	// The full name of the license.
	Name string `json:"name"`
	// The full text of the license.
	Text *string `json:"text"`
	// The full text of the license formatted as HTML.
	TextHTML *string `json:"textHTML"`
	// The reference URL of the license with more information.
	ReferenceURL *string `json:"referenceURL"`
	// The details URL of the license with information in machine readable format.
	DetailsURL *string `json:"detailsURL"`
	// The type (strength) of the license.
	Type LicenseType `json:"type"`
	// Indicates if the license is a standard license.
	IsSpdx bool `json:"isSpdx"`
	// Indicates if the license identifier is deprecated in favor of another license identifier and should no longer be used.
	IsDeprecated bool `json:"isDeprecated"`
	// Indicates if the license is OSI approved.
	IsOsiApproved bool `json:"isOsiApproved"`
	// Indicates if the license is FSF approved.
	IsFsfLibre bool `json:"isFsfLibre"`
	// Indicates if the license is considered a LOSH unapproved license.
	IsBlocked bool `json:"isBlocked"`
}

func (License) IsNode() {}

type LicenseAggregateResult struct {
	Count           *int64  `json:"count"`
	XidMin          *string `json:"xidMin"`
	XidMax          *string `json:"xidMax"`
	NameMin         *string `json:"nameMin"`
	NameMax         *string `json:"nameMax"`
	TextMin         *string `json:"textMin"`
	TextMax         *string `json:"textMax"`
	TextHTMLMin     *string `json:"textHTMLMin"`
	TextHTMLMax     *string `json:"textHTMLMax"`
	ReferenceURLMin *string `json:"referenceURLMin"`
	ReferenceURLMax *string `json:"referenceURLMax"`
	DetailsURLMin   *string `json:"detailsURLMin"`
	DetailsURLMax   *string `json:"detailsURLMax"`
}

type LicenseFilter struct {
	ID            []string                                            `json:"id,omitempty"`
	Xid           *StringHashFilterStringRegExpFilterStringTermFilter `json:"xid,omitempty"`
	Name          *StringRegExpFilterStringTermFilter                 `json:"name,omitempty"`
	IsSpdx        *bool                                               `json:"isSpdx,omitempty"`
	IsDeprecated  *bool                                               `json:"isDeprecated,omitempty"`
	IsOsiApproved *bool                                               `json:"isOsiApproved,omitempty"`
	IsFsfLibre    *bool                                               `json:"isFsfLibre,omitempty"`
	IsBlocked     *bool                                               `json:"isBlocked,omitempty"`
	Has           []*LicenseHasFilter                                 `json:"has,omitempty"`
	And           []*LicenseFilter                                    `json:"and,omitempty"`
	Or            []*LicenseFilter                                    `json:"or,omitempty"`
	Not           *LicenseFilter                                      `json:"not,omitempty"`
}

type LicenseOrder struct {
	Asc  *LicenseOrderable `json:"asc,omitempty"`
	Desc *LicenseOrderable `json:"desc,omitempty"`
	Then *LicenseOrder     `json:"then,omitempty"`
}

type LicensePatch struct {
	// The human readable ID of the license. If the license is a SPDX license, the ID is the SPDX ID.
	Xid *string `json:"xid,omitempty"`
	// The full name of the license.
	Name *string `json:"name,omitempty"`
	// The full text of the license.
	Text *string `json:"text,omitempty"`
	// The full text of the license formatted as HTML.
	TextHTML *string `json:"textHTML,omitempty"`
	// The reference URL of the license with more information.
	ReferenceURL *string `json:"referenceURL,omitempty"`
	// The details URL of the license with information in machine readable format.
	DetailsURL *string `json:"detailsURL,omitempty"`
	// The type (strength) of the license.
	Type *LicenseType `json:"type,omitempty"`
	// Indicates if the license is a standard license.
	IsSpdx *bool `json:"isSpdx,omitempty"`
	// Indicates if the license identifier is deprecated in favor of another license identifier and should no longer be used.
	IsDeprecated *bool `json:"isDeprecated,omitempty"`
	// Indicates if the license is OSI approved.
	IsOsiApproved *bool `json:"isOsiApproved,omitempty"`
	// Indicates if the license is FSF approved.
	IsFsfLibre *bool `json:"isFsfLibre,omitempty"`
	// Indicates if the license is considered a LOSH unapproved license.
	IsBlocked *bool `json:"isBlocked,omitempty"`
}

type LicenseRef struct {
	ID *string `json:"id,omitempty"`
	// The human readable ID of the license. If the license is a SPDX license, the ID is the SPDX ID.
	Xid *string `json:"xid,omitempty"`
	// The full name of the license.
	Name *string `json:"name,omitempty"`
	// The full text of the license.
	Text *string `json:"text,omitempty"`
	// The full text of the license formatted as HTML.
	TextHTML *string `json:"textHTML,omitempty"`
	// The reference URL of the license with more information.
	ReferenceURL *string `json:"referenceURL,omitempty"`
	// The details URL of the license with information in machine readable format.
	DetailsURL *string `json:"detailsURL,omitempty"`
	// The type (strength) of the license.
	Type *LicenseType `json:"type,omitempty"`
	// Indicates if the license is a standard license.
	IsSpdx *bool `json:"isSpdx,omitempty"`
	// Indicates if the license identifier is deprecated in favor of another license identifier and should no longer be used.
	IsDeprecated *bool `json:"isDeprecated,omitempty"`
	// Indicates if the license is OSI approved.
	IsOsiApproved *bool `json:"isOsiApproved,omitempty"`
	// Indicates if the license is FSF approved.
	IsFsfLibre *bool `json:"isFsfLibre,omitempty"`
	// Indicates if the license is considered a LOSH unapproved license.
	IsBlocked *bool `json:"isBlocked,omitempty"`
}

type ManufacturingProcess struct {
	ID string `json:"id"`
	// The name of the manufacturing process.
	Name string `json:"name"`
	// The description of the manufacturing process.
	Description *string `json:"description"`
}

func (ManufacturingProcess) IsNode() {}

type ManufacturingProcessAggregateResult struct {
	Count          *int64  `json:"count"`
	NameMin        *string `json:"nameMin"`
	NameMax        *string `json:"nameMax"`
	DescriptionMin *string `json:"descriptionMin"`
	DescriptionMax *string `json:"descriptionMax"`
}

type ManufacturingProcessFilter struct {
	ID   []string                                `json:"id,omitempty"`
	Name *StringFullTextFilterStringRegExpFilter `json:"name,omitempty"`
	Has  []*ManufacturingProcessHasFilter        `json:"has,omitempty"`
	And  []*ManufacturingProcessFilter           `json:"and,omitempty"`
	Or   []*ManufacturingProcessFilter           `json:"or,omitempty"`
	Not  *ManufacturingProcessFilter             `json:"not,omitempty"`
}

type ManufacturingProcessOrder struct {
	Asc  *ManufacturingProcessOrderable `json:"asc,omitempty"`
	Desc *ManufacturingProcessOrderable `json:"desc,omitempty"`
	Then *ManufacturingProcessOrder     `json:"then,omitempty"`
}

type ManufacturingProcessPatch struct {
	// The name of the manufacturing process.
	Name *string `json:"name,omitempty"`
	// The description of the manufacturing process.
	Description *string `json:"description,omitempty"`
}

type ManufacturingProcessRef struct {
	ID *string `json:"id,omitempty"`
	// The name of the manufacturing process.
	Name *string `json:"name,omitempty"`
	// The description of the manufacturing process.
	Description *string `json:"description,omitempty"`
}

type Material struct {
	ID string `json:"id"`
	// The name of the material.
	Name string `json:"name"`
	// The description of the material.
	Description *string `json:"description"`
}

func (Material) IsNode() {}

type MaterialAggregateResult struct {
	Count          *int64  `json:"count"`
	NameMin        *string `json:"nameMin"`
	NameMax        *string `json:"nameMax"`
	DescriptionMin *string `json:"descriptionMin"`
	DescriptionMax *string `json:"descriptionMax"`
}

type MaterialFilter struct {
	ID   []string              `json:"id,omitempty"`
	Name *StringFullTextFilter `json:"name,omitempty"`
	Has  []*MaterialHasFilter  `json:"has,omitempty"`
	And  []*MaterialFilter     `json:"and,omitempty"`
	Or   []*MaterialFilter     `json:"or,omitempty"`
	Not  *MaterialFilter       `json:"not,omitempty"`
}

type MaterialOrder struct {
	Asc  *MaterialOrderable `json:"asc,omitempty"`
	Desc *MaterialOrderable `json:"desc,omitempty"`
	Then *MaterialOrder     `json:"then,omitempty"`
}

type MaterialPatch struct {
	// The name of the material.
	Name *string `json:"name,omitempty"`
	// The description of the material.
	Description *string `json:"description,omitempty"`
}

type MaterialRef struct {
	ID *string `json:"id,omitempty"`
	// The name of the material.
	Name *string `json:"name,omitempty"`
	// The description of the material.
	Description *string `json:"description,omitempty"`
}

type MultiPolygon struct {
	Polygons []*Polygon `json:"polygons"`
}

type MultiPolygonRef struct {
	Polygons []*PolygonRef `json:"polygons"`
}

type NearFilter struct {
	Distance   float64  `json:"distance"`
	Coordinate PointRef `json:"coordinate"`
}

type NodeAggregateResult struct {
	Count *int64 `json:"count"`
}

type NodeFilter struct {
	ID  []string    `json:"id,omitempty"`
	Not *NodeFilter `json:"not,omitempty"`
}

type NodeRef struct {
	// The identifier of the object.
	ID string `json:"id"`
}

// A type of dimension in form of a box. Unit: m
type OpenSCADDimensions struct {
	ID       string `json:"id"`
	Openscad string `json:"openscad"`
	Unit     string `json:"unit"`
}

func (OpenSCADDimensions) IsOuterDimensions() {}
func (OpenSCADDimensions) IsNode()            {}

type OpenSCADDimensionsAggregateResult struct {
	Count       *int64  `json:"count"`
	OpenscadMin *string `json:"openscadMin"`
	OpenscadMax *string `json:"openscadMax"`
	UnitMin     *string `json:"unitMin"`
	UnitMax     *string `json:"unitMax"`
}

type OpenSCADDimensionsFilter struct {
	ID  []string                       `json:"id,omitempty"`
	Has []*OpenSCADDimensionsHasFilter `json:"has,omitempty"`
	And []*OpenSCADDimensionsFilter    `json:"and,omitempty"`
	Or  []*OpenSCADDimensionsFilter    `json:"or,omitempty"`
	Not *OpenSCADDimensionsFilter      `json:"not,omitempty"`
}

type OpenSCADDimensionsOrder struct {
	Asc  *OpenSCADDimensionsOrderable `json:"asc,omitempty"`
	Desc *OpenSCADDimensionsOrderable `json:"desc,omitempty"`
	Then *OpenSCADDimensionsOrder     `json:"then,omitempty"`
}

type OpenSCADDimensionsPatch struct {
	Openscad *string `json:"openscad,omitempty"`
	Unit     *string `json:"unit,omitempty"`
}

type OpenSCADDimensionsRef struct {
	ID       *string `json:"id,omitempty"`
	Openscad *string `json:"openscad,omitempty"`
	Unit     *string `json:"unit,omitempty"`
}

type OuterDimensionsFilter struct {
	MemberTypes                 []OuterDimensionsType        `json:"memberTypes,omitempty"`
	BoundingBoxDimensionsFilter *BoundingBoxDimensionsFilter `json:"boundingBoxDimensionsFilter,omitempty"`
	OpenSCADDimensionsFilter    *OpenSCADDimensionsFilter    `json:"openSCADDimensionsFilter,omitempty"`
}

type OuterDimensionsRef struct {
	BoundingBoxDimensionsRef *BoundingBoxDimensionsRef `json:"boundingBoxDimensionsRef,omitempty"`
	OpenSCADDimensionsRef    *OpenSCADDimensionsRef    `json:"openSCADDimensionsRef,omitempty"`
}

type Point struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type PointGeoFilter struct {
	Near   *NearFilter   `json:"near,omitempty"`
	Within *WithinFilter `json:"within,omitempty"`
}

type PointList struct {
	Points []*Point `json:"points"`
}

type PointListRef struct {
	Points []*PointRef `json:"points"`
}

type PointRef struct {
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type Polygon struct {
	Coordinates []*PointList `json:"coordinates"`
}

type PolygonGeoFilter struct {
	Near       *NearFilter       `json:"near,omitempty"`
	Within     *WithinFilter     `json:"within,omitempty"`
	Contains   *ContainsFilter   `json:"contains,omitempty"`
	Intersects *IntersectsFilter `json:"intersects,omitempty"`
}

type PolygonRef struct {
	Coordinates []*PointListRef `json:"coordinates"`
}

// A product is a tangible object with a name, description, website representation and at least one release.
type Product struct {
	DiscoveredAt  time.Time  `json:"discoveredAt"`
	LastIndexedAt time.Time  `json:"lastIndexedAt"`
	DataSource    Repository `json:"dataSource"`
	ID            string     `json:"id"`
	//  The unique human readable identifier of the product in the format: `domain.tld/owner/repo/file-path`. For example:
	// - `github.com/aisbergg/foobar/okh.yml`
	// - `wikifactory.com/@aisbergg/foobar/-`
	// - `oshwa.org/-/-/us000000.html`
	Xid string `json:"xid"`
	// The name of the product.
	Name string `json:"name"`
	// The short description of the product.
	Description string `json:"description"`
	// The language in which the documentation is written.
	DocumentationLanguage string `json:"documentationLanguage"`
	// The latest version of the product.
	Version string `json:"version"`
	// The license used for the component.
	License *License `json:"license"`
	// The license holder of the product.
	Licensor UserOrGroup `json:"licensor"`
	// The product website URL, if any.
	Website *string `json:"website"`
	// Indicates if the product is still actively developed or not.
	State ProductState `json:"state"`
	// The date and time the product was last upated. This doesn't necessarily mean that a new release was created.
	LastUpdatedAt *time.Time `json:"lastUpdatedAt"`
	// The latest release of the product.
	Release Component `json:"release"`
	// A list of all releases of the product.
	Releases []*Component `json:"releases"`
	// The new name of the product. If not set, the product was never renamed.
	RenamedTo *Product `json:"renamedTo"`
	// The previous name of the product. If not set, the product was never renamed.
	RenamedFrom *Product `json:"renamedFrom"`
	// The original product that this product is based on.
	ForkOf *Product `json:"forkOf"`
	// A list of products that are based on this product.
	Forks []*Product `json:"forks"`
	// The number of forks of the product. It might be higher than the number of indexed forks, because not all forks might satisfy the conditions for being indexed.
	ForkCount *int64 `json:"forkCount"`
	// The number of people starring the product.
	StarCount *int64 `json:"starCount"`
	// A list of all tags associated with the product.
	Tags []*Tag `json:"tags"`
	// The category of the product.
	Category          *Category                 `json:"category"`
	ReleasesAggregate *ComponentAggregateResult `json:"releasesAggregate"`
	ForksAggregate    *ProductAggregateResult   `json:"forksAggregate"`
	TagsAggregate     *TagAggregateResult       `json:"tagsAggregate"`
}

func (Product) IsNode()        {}
func (Product) IsCrawlerMeta() {}

type ProductAggregateResult struct {
	Count                    *int64     `json:"count"`
	DiscoveredAtMin          *time.Time `json:"discoveredAtMin"`
	DiscoveredAtMax          *time.Time `json:"discoveredAtMax"`
	LastIndexedAtMin         *time.Time `json:"lastIndexedAtMin"`
	LastIndexedAtMax         *time.Time `json:"lastIndexedAtMax"`
	XidMin                   *string    `json:"xidMin"`
	XidMax                   *string    `json:"xidMax"`
	NameMin                  *string    `json:"nameMin"`
	NameMax                  *string    `json:"nameMax"`
	DescriptionMin           *string    `json:"descriptionMin"`
	DescriptionMax           *string    `json:"descriptionMax"`
	DocumentationLanguageMin *string    `json:"documentationLanguageMin"`
	DocumentationLanguageMax *string    `json:"documentationLanguageMax"`
	VersionMin               *string    `json:"versionMin"`
	VersionMax               *string    `json:"versionMax"`
	WebsiteMin               *string    `json:"websiteMin"`
	WebsiteMax               *string    `json:"websiteMax"`
	LastUpdatedAtMin         *time.Time `json:"lastUpdatedAtMin"`
	LastUpdatedAtMax         *time.Time `json:"lastUpdatedAtMax"`
	ForkCountMin             *int64     `json:"forkCountMin"`
	ForkCountMax             *int64     `json:"forkCountMax"`
	ForkCountSum             *int64     `json:"forkCountSum"`
	ForkCountAvg             *float64   `json:"forkCountAvg"`
	StarCountMin             *int64     `json:"starCountMin"`
	StarCountMax             *int64     `json:"starCountMax"`
	StarCountSum             *int64     `json:"starCountSum"`
	StarCountAvg             *float64   `json:"starCountAvg"`
}

type ProductFilter struct {
	DiscoveredAt          *DateTimeFilter                                         `json:"discoveredAt,omitempty"`
	LastIndexedAt         *DateTimeFilter                                         `json:"lastIndexedAt,omitempty"`
	ID                    []string                                                `json:"id,omitempty"`
	Xid                   *StringHashFilter                                       `json:"xid,omitempty"`
	Name                  *StringFullTextFilterStringHashFilterStringRegExpFilter `json:"name,omitempty"`
	Description           *StringFullTextFilterStringRegExpFilter                 `json:"description,omitempty"`
	DocumentationLanguage *StringRegExpFilter                                     `json:"documentationLanguage,omitempty"`
	Version               *StringTermFilter                                       `json:"version,omitempty"`
	Website               *StringFullTextFilterStringHashFilterStringRegExpFilter `json:"website,omitempty"`
	State                 *ProductStateHash                                       `json:"state,omitempty"`
	LastUpdatedAt         *DateTimeFilter                                         `json:"lastUpdatedAt,omitempty"`
	ForkCount             *IntFilter                                              `json:"forkCount,omitempty"`
	StarCount             *IntFilter                                              `json:"starCount,omitempty"`
	Has                   []*ProductHasFilter                                     `json:"has,omitempty"`
	And                   []*ProductFilter                                        `json:"and,omitempty"`
	Or                    []*ProductFilter                                        `json:"or,omitempty"`
	Not                   *ProductFilter                                          `json:"not,omitempty"`
}

type ProductOrder struct {
	Asc  *ProductOrderable `json:"asc,omitempty"`
	Desc *ProductOrderable `json:"desc,omitempty"`
	Then *ProductOrder     `json:"then,omitempty"`
}

type ProductPatch struct {
	DiscoveredAt  *time.Time     `json:"discoveredAt,omitempty"`
	LastIndexedAt *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource    *RepositoryRef `json:"dataSource,omitempty"`
	//  The unique human readable identifier of the product in the format: `domain.tld/owner/repo/file-path`. For example:
	// - `github.com/aisbergg/foobar/okh.yml`
	// - `wikifactory.com/@aisbergg/foobar/-`
	// - `oshwa.org/-/-/us000000.html`
	Xid *string `json:"xid,omitempty"`
	// The name of the product.
	Name *string `json:"name,omitempty"`
	// The short description of the product.
	Description *string `json:"description,omitempty"`
	// The language in which the documentation is written.
	DocumentationLanguage *string `json:"documentationLanguage,omitempty"`
	// The latest version of the product.
	Version  *string         `json:"version,omitempty"`
	License  *LicenseRef     `json:"license,omitempty"`
	Licensor *UserOrGroupRef `json:"licensor,omitempty"`
	// The product website URL, if any.
	Website *string `json:"website,omitempty"`
	// Indicates if the product is still actively developed or not.
	State *ProductState `json:"state,omitempty"`
	// The date and time the product was last upated. This doesn't necessarily mean that a new release was created.
	LastUpdatedAt *time.Time      `json:"lastUpdatedAt,omitempty"`
	Release       *ComponentRef   `json:"release,omitempty"`
	Releases      []*ComponentRef `json:"releases,omitempty"`
	RenamedTo     *ProductRef     `json:"renamedTo,omitempty"`
	RenamedFrom   *ProductRef     `json:"renamedFrom,omitempty"`
	ForkOf        *ProductRef     `json:"forkOf,omitempty"`
	Forks         []*ProductRef   `json:"forks,omitempty"`
	// The number of forks of the product. It might be higher than the number of indexed forks, because not all forks might satisfy the conditions for being indexed.
	ForkCount *int64 `json:"forkCount,omitempty"`
	// The number of people starring the product.
	StarCount *int64       `json:"starCount,omitempty"`
	Tags      []*TagRef    `json:"tags,omitempty"`
	Category  *CategoryRef `json:"category,omitempty"`
}

type ProductRef struct {
	ID            *string        `json:"id,omitempty"`
	DiscoveredAt  *time.Time     `json:"discoveredAt,omitempty"`
	LastIndexedAt *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource    *RepositoryRef `json:"dataSource,omitempty"`
	//  The unique human readable identifier of the product in the format: `domain.tld/owner/repo/file-path`. For example:
	// - `github.com/aisbergg/foobar/okh.yml`
	// - `wikifactory.com/@aisbergg/foobar/-`
	// - `oshwa.org/-/-/us000000.html`
	Xid *string `json:"xid,omitempty"`
	// The name of the product.
	Name *string `json:"name,omitempty"`
	// The short description of the product.
	Description *string `json:"description,omitempty"`
	// The language in which the documentation is written.
	DocumentationLanguage *string `json:"documentationLanguage,omitempty"`
	// The latest version of the product.
	Version  *string         `json:"version,omitempty"`
	License  *LicenseRef     `json:"license,omitempty"`
	Licensor *UserOrGroupRef `json:"licensor,omitempty"`
	// The product website URL, if any.
	Website *string `json:"website,omitempty"`
	// Indicates if the product is still actively developed or not.
	State *ProductState `json:"state,omitempty"`
	// The date and time the product was last upated. This doesn't necessarily mean that a new release was created.
	LastUpdatedAt *time.Time      `json:"lastUpdatedAt,omitempty"`
	Release       *ComponentRef   `json:"release,omitempty"`
	Releases      []*ComponentRef `json:"releases,omitempty"`
	RenamedTo     *ProductRef     `json:"renamedTo,omitempty"`
	RenamedFrom   *ProductRef     `json:"renamedFrom,omitempty"`
	ForkOf        *ProductRef     `json:"forkOf,omitempty"`
	Forks         []*ProductRef   `json:"forks,omitempty"`
	// The number of forks of the product. It might be higher than the number of indexed forks, because not all forks might satisfy the conditions for being indexed.
	ForkCount *int64 `json:"forkCount,omitempty"`
	// The number of people starring the product.
	StarCount *int64       `json:"starCount,omitempty"`
	Tags      []*TagRef    `json:"tags,omitempty"`
	Category  *CategoryRef `json:"category,omitempty"`
}

type ProductStateHash struct {
	Eq *ProductState   `json:"eq,omitempty"`
	In []*ProductState `json:"in,omitempty"`
}

// Repository represents a data source. It might be a Git repository (+ manifest file), a website or other kind of data source.
type Repository struct {
	ID string `json:"id"`
	//  The unique human readable identifier of the repository in the format: `domain.tld/owner/repo/ref/file-path`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-`
	// - `oshwa.org/-/-/1.0.0/us000000.html`
	Xid string `json:"xid"`
	// Nice URL of the repository where the result is The repository URL where the component was discoverd from or is developed in.
	URL string `json:"url"`
	// The permanent URL to the specific release version.
	PermaURL string `json:"permaUrl"`
	// The host platform of the repository.
	Host Host `json:"host"`
	// The owner (user or group) of the repository, if any.
	Owner UserOrGroup `json:"owner"`
	// The repository name, if any.
	Name *string `json:"name"`
	// The reference, if any. This could be a Git tag or branch for example.
	Reference *string `json:"reference"`
	// The path of the file or other resource inside the repository, if any.
	Path *string `json:"path"`
	// The actual file that the repository represents. If the repository is a Git repository, this is the manifest file.
	File *File `json:"file"`
}

func (Repository) IsNode() {}

type RepositoryAggregateResult struct {
	Count        *int64  `json:"count"`
	XidMin       *string `json:"xidMin"`
	XidMax       *string `json:"xidMax"`
	URLMin       *string `json:"urlMin"`
	URLMax       *string `json:"urlMax"`
	PermaURLMin  *string `json:"permaUrlMin"`
	PermaURLMax  *string `json:"permaUrlMax"`
	NameMin      *string `json:"nameMin"`
	NameMax      *string `json:"nameMax"`
	ReferenceMin *string `json:"referenceMin"`
	ReferenceMax *string `json:"referenceMax"`
	PathMin      *string `json:"pathMin"`
	PathMax      *string `json:"pathMax"`
}

type RepositoryFilter struct {
	ID   []string                                                `json:"id,omitempty"`
	Xid  *StringHashFilter                                       `json:"xid,omitempty"`
	Name *StringFullTextFilterStringHashFilterStringRegExpFilter `json:"name,omitempty"`
	Has  []*RepositoryHasFilter                                  `json:"has,omitempty"`
	And  []*RepositoryFilter                                     `json:"and,omitempty"`
	Or   []*RepositoryFilter                                     `json:"or,omitempty"`
	Not  *RepositoryFilter                                       `json:"not,omitempty"`
}

type RepositoryOrder struct {
	Asc  *RepositoryOrderable `json:"asc,omitempty"`
	Desc *RepositoryOrderable `json:"desc,omitempty"`
	Then *RepositoryOrder     `json:"then,omitempty"`
}

type RepositoryPatch struct {
	//  The unique human readable identifier of the repository in the format: `domain.tld/owner/repo/ref/file-path`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-`
	// - `oshwa.org/-/-/1.0.0/us000000.html`
	Xid *string `json:"xid,omitempty"`
	// Nice URL of the repository where the result is The repository URL where the component was discoverd from or is developed in.
	URL *string `json:"url,omitempty"`
	// The permanent URL to the specific release version.
	PermaURL *string         `json:"permaUrl,omitempty"`
	Host     *HostRef        `json:"host,omitempty"`
	Owner    *UserOrGroupRef `json:"owner,omitempty"`
	// The repository name, if any.
	Name *string `json:"name,omitempty"`
	// The reference, if any. This could be a Git tag or branch for example.
	Reference *string `json:"reference,omitempty"`
	// The path of the file or other resource inside the repository, if any.
	Path *string  `json:"path,omitempty"`
	File *FileRef `json:"file,omitempty"`
}

type RepositoryRef struct {
	ID *string `json:"id,omitempty"`
	//  The unique human readable identifier of the repository in the format: `domain.tld/owner/repo/ref/file-path`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg/foobar/1.0.0/path%2Fto%2Fokh.yml`
	// - `wikifactory.com/@aisbergg/foobar/a1b2c3d/-`
	// - `oshwa.org/-/-/1.0.0/us000000.html`
	Xid *string `json:"xid,omitempty"`
	// Nice URL of the repository where the result is The repository URL where the component was discoverd from or is developed in.
	URL *string `json:"url,omitempty"`
	// The permanent URL to the specific release version.
	PermaURL *string         `json:"permaUrl,omitempty"`
	Host     *HostRef        `json:"host,omitempty"`
	Owner    *UserOrGroupRef `json:"owner,omitempty"`
	// The repository name, if any.
	Name *string `json:"name,omitempty"`
	// The reference, if any. This could be a Git tag or branch for example.
	Reference *string `json:"reference,omitempty"`
	// The path of the file or other resource inside the repository, if any.
	Path *string  `json:"path,omitempty"`
	File *FileRef `json:"file,omitempty"`
}

type Software struct {
	DiscoveredAt          time.Time  `json:"discoveredAt"`
	LastIndexedAt         time.Time  `json:"lastIndexedAt"`
	DataSource            Repository `json:"dataSource"`
	ID                    string     `json:"id"`
	Release               *string    `json:"release"`
	InstallationGuide     *File      `json:"installationGuide"`
	DocumentationLanguage *string    `json:"documentationLanguage"`
	License               *License   `json:"license"`
	Licensor              *string    `json:"licensor"`
}

func (Software) IsNode()        {}
func (Software) IsCrawlerMeta() {}

type SoftwareAggregateResult struct {
	Count                    *int64     `json:"count"`
	DiscoveredAtMin          *time.Time `json:"discoveredAtMin"`
	DiscoveredAtMax          *time.Time `json:"discoveredAtMax"`
	LastIndexedAtMin         *time.Time `json:"lastIndexedAtMin"`
	LastIndexedAtMax         *time.Time `json:"lastIndexedAtMax"`
	ReleaseMin               *string    `json:"releaseMin"`
	ReleaseMax               *string    `json:"releaseMax"`
	DocumentationLanguageMin *string    `json:"documentationLanguageMin"`
	DocumentationLanguageMax *string    `json:"documentationLanguageMax"`
	LicensorMin              *string    `json:"licensorMin"`
	LicensorMax              *string    `json:"licensorMax"`
}

type SoftwareFilter struct {
	DiscoveredAt  *DateTimeFilter      `json:"discoveredAt,omitempty"`
	LastIndexedAt *DateTimeFilter      `json:"lastIndexedAt,omitempty"`
	ID            []string             `json:"id,omitempty"`
	Has           []*SoftwareHasFilter `json:"has,omitempty"`
	And           []*SoftwareFilter    `json:"and,omitempty"`
	Or            []*SoftwareFilter    `json:"or,omitempty"`
	Not           *SoftwareFilter      `json:"not,omitempty"`
}

type SoftwareOrder struct {
	Asc  *SoftwareOrderable `json:"asc,omitempty"`
	Desc *SoftwareOrderable `json:"desc,omitempty"`
	Then *SoftwareOrder     `json:"then,omitempty"`
}

type SoftwarePatch struct {
	DiscoveredAt          *time.Time     `json:"discoveredAt,omitempty"`
	LastIndexedAt         *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource            *RepositoryRef `json:"dataSource,omitempty"`
	Release               *string        `json:"release,omitempty"`
	InstallationGuide     *FileRef       `json:"installationGuide,omitempty"`
	DocumentationLanguage *string        `json:"documentationLanguage,omitempty"`
	License               *LicenseRef    `json:"license,omitempty"`
	Licensor              *string        `json:"licensor,omitempty"`
}

type SoftwareRef struct {
	ID                    *string        `json:"id,omitempty"`
	DiscoveredAt          *time.Time     `json:"discoveredAt,omitempty"`
	LastIndexedAt         *time.Time     `json:"lastIndexedAt,omitempty"`
	DataSource            *RepositoryRef `json:"dataSource,omitempty"`
	Release               *string        `json:"release,omitempty"`
	InstallationGuide     *FileRef       `json:"installationGuide,omitempty"`
	DocumentationLanguage *string        `json:"documentationLanguage,omitempty"`
	License               *LicenseRef    `json:"license,omitempty"`
	Licensor              *string        `json:"licensor,omitempty"`
}

type StringExactFilter struct {
	Eq      *string      `json:"eq,omitempty"`
	In      []*string    `json:"in,omitempty"`
	Le      *string      `json:"le,omitempty"`
	Lt      *string      `json:"lt,omitempty"`
	Ge      *string      `json:"ge,omitempty"`
	Gt      *string      `json:"gt,omitempty"`
	Between *StringRange `json:"between,omitempty"`
}

type StringFullTextFilter struct {
	Alloftext *string `json:"alloftext,omitempty"`
	Anyoftext *string `json:"anyoftext,omitempty"`
}

type StringFullTextFilterStringHashFilterStringRegExpFilter struct {
	Alloftext *string   `json:"alloftext,omitempty"`
	Anyoftext *string   `json:"anyoftext,omitempty"`
	Eq        *string   `json:"eq,omitempty"`
	In        []*string `json:"in,omitempty"`
	Regexp    *string   `json:"regexp,omitempty"`
}

type StringFullTextFilterStringRegExpFilter struct {
	Alloftext *string `json:"alloftext,omitempty"`
	Anyoftext *string `json:"anyoftext,omitempty"`
	Regexp    *string `json:"regexp,omitempty"`
}

type StringHashFilter struct {
	Eq *string   `json:"eq,omitempty"`
	In []*string `json:"in,omitempty"`
}

type StringHashFilterStringRegExpFilter struct {
	Eq     *string   `json:"eq,omitempty"`
	In     []*string `json:"in,omitempty"`
	Regexp *string   `json:"regexp,omitempty"`
}

type StringHashFilterStringRegExpFilterStringTermFilter struct {
	Eq         *string   `json:"eq,omitempty"`
	In         []*string `json:"in,omitempty"`
	Regexp     *string   `json:"regexp,omitempty"`
	Allofterms *string   `json:"allofterms,omitempty"`
	Anyofterms *string   `json:"anyofterms,omitempty"`
}

type StringOrFloatFilter struct {
	MemberTypes   []StringOrFloatType `json:"memberTypes,omitempty"`
	StringVFilter *StringVFilter      `json:"stringVFilter,omitempty"`
	FloatVFilter  *FloatVFilter       `json:"floatVFilter,omitempty"`
}

type StringOrFloatRef struct {
	StringVRef *StringVRef `json:"stringVRef,omitempty"`
	FloatVRef  *FloatVRef  `json:"floatVRef,omitempty"`
}

type StringRange struct {
	Min string `json:"min"`
	Max string `json:"max"`
}

type StringRegExpFilter struct {
	Regexp *string `json:"regexp,omitempty"`
}

type StringRegExpFilterStringTermFilter struct {
	Regexp     *string `json:"regexp,omitempty"`
	Allofterms *string `json:"allofterms,omitempty"`
	Anyofterms *string `json:"anyofterms,omitempty"`
}

type StringTermFilter struct {
	Allofterms *string `json:"allofterms,omitempty"`
	Anyofterms *string `json:"anyofterms,omitempty"`
}

type StringV struct {
	ID    string `json:"id"`
	Value string `json:"value"`
}

func (StringV) IsStringOrFloat() {}
func (StringV) IsNode()          {}

type StringVAggregateResult struct {
	Count    *int64  `json:"count"`
	ValueMin *string `json:"valueMin"`
	ValueMax *string `json:"valueMax"`
}

type StringVFilter struct {
	ID  []string            `json:"id,omitempty"`
	Has []*StringVHasFilter `json:"has,omitempty"`
	And []*StringVFilter    `json:"and,omitempty"`
	Or  []*StringVFilter    `json:"or,omitempty"`
	Not *StringVFilter      `json:"not,omitempty"`
}

type StringVOrder struct {
	Asc  *StringVOrderable `json:"asc,omitempty"`
	Desc *StringVOrderable `json:"desc,omitempty"`
	Then *StringVOrder     `json:"then,omitempty"`
}

type StringVPatch struct {
	Value *string `json:"value,omitempty"`
}

type StringVRef struct {
	ID    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

// A tag is a keyword or fulltext used to describe a product.
type Tag struct {
	ID string `json:"id"`
	// The human readable identifier of the tag.
	Xid string `json:"xid"`
	// The name of the tag.
	Name string `json:"name"`
	// List of alliases of the tag.
	Aliases []*Tag `json:"aliases"`
	// List of related tags.
	Related          []*Tag              `json:"related"`
	AliasesAggregate *TagAggregateResult `json:"aliasesAggregate"`
	RelatedAggregate *TagAggregateResult `json:"relatedAggregate"`
}

func (Tag) IsNode() {}

type TagAggregateResult struct {
	Count   *int64  `json:"count"`
	XidMin  *string `json:"xidMin"`
	XidMax  *string `json:"xidMax"`
	NameMin *string `json:"nameMin"`
	NameMax *string `json:"nameMax"`
}

type TagFilter struct {
	ID   []string                                `json:"id,omitempty"`
	Xid  *StringHashFilter                       `json:"xid,omitempty"`
	Name *StringFullTextFilterStringRegExpFilter `json:"name,omitempty"`
	Has  []*TagHasFilter                         `json:"has,omitempty"`
	And  []*TagFilter                            `json:"and,omitempty"`
	Or   []*TagFilter                            `json:"or,omitempty"`
	Not  *TagFilter                              `json:"not,omitempty"`
}

type TagOrder struct {
	Asc  *TagOrderable `json:"asc,omitempty"`
	Desc *TagOrderable `json:"desc,omitempty"`
	Then *TagOrder     `json:"then,omitempty"`
}

type TagPatch struct {
	// The human readable identifier of the tag.
	Xid *string `json:"xid,omitempty"`
	// The name of the tag.
	Name    *string   `json:"name,omitempty"`
	Aliases []*TagRef `json:"aliases,omitempty"`
	Related []*TagRef `json:"related,omitempty"`
}

type TagRef struct {
	ID *string `json:"id,omitempty"`
	// The human readable identifier of the tag.
	Xid *string `json:"xid,omitempty"`
	// The name of the tag.
	Name    *string   `json:"name,omitempty"`
	Aliases []*TagRef `json:"aliases,omitempty"`
	Related []*TagRef `json:"related,omitempty"`
}

// The technical standard used to create a component. For example: "ISO/IEC", "DIN", etc.
type TechnicalStandard struct {
	ID string `json:"id"`
	// The human readable identifier of the standard (lowercased name). For example: "din en 1335".
	Xid string `json:"xid"`
	// The name of the standard. For example: "DIN EN 1335".
	Name string `json:"name"`
	// The description for the standard.
	Description *string `json:"description"`
	// A list of components that meet the standard.
	Components          []*Component              `json:"components"`
	ComponentsAggregate *ComponentAggregateResult `json:"componentsAggregate"`
}

func (TechnicalStandard) IsNode() {}

type TechnicalStandardAggregateResult struct {
	Count          *int64  `json:"count"`
	XidMin         *string `json:"xidMin"`
	XidMax         *string `json:"xidMax"`
	NameMin        *string `json:"nameMin"`
	NameMax        *string `json:"nameMax"`
	DescriptionMin *string `json:"descriptionMin"`
	DescriptionMax *string `json:"descriptionMax"`
}

type TechnicalStandardFilter struct {
	ID   []string                                `json:"id,omitempty"`
	Xid  *StringHashFilter                       `json:"xid,omitempty"`
	Name *StringFullTextFilterStringRegExpFilter `json:"name,omitempty"`
	Has  []*TechnicalStandardHasFilter           `json:"has,omitempty"`
	And  []*TechnicalStandardFilter              `json:"and,omitempty"`
	Or   []*TechnicalStandardFilter              `json:"or,omitempty"`
	Not  *TechnicalStandardFilter                `json:"not,omitempty"`
}

type TechnicalStandardOrder struct {
	Asc  *TechnicalStandardOrderable `json:"asc,omitempty"`
	Desc *TechnicalStandardOrderable `json:"desc,omitempty"`
	Then *TechnicalStandardOrder     `json:"then,omitempty"`
}

type TechnicalStandardPatch struct {
	// The human readable identifier of the standard (lowercased name). For example: "din en 1335".
	Xid *string `json:"xid,omitempty"`
	// The name of the standard. For example: "DIN EN 1335".
	Name *string `json:"name,omitempty"`
	// The description for the standard.
	Description *string         `json:"description,omitempty"`
	Components  []*ComponentRef `json:"components,omitempty"`
}

type TechnicalStandardRef struct {
	ID *string `json:"id,omitempty"`
	// The human readable identifier of the standard (lowercased name). For example: "din en 1335".
	Xid *string `json:"xid,omitempty"`
	// The name of the standard. For example: "DIN EN 1335".
	Name *string `json:"name,omitempty"`
	// The description for the standard.
	Description *string         `json:"description,omitempty"`
	Components  []*ComponentRef `json:"components,omitempty"`
}

// The technology specific documentation criteria (TSDC) specifies the requirements for the technical documentation
// of Open Source Hardware (OSH). See: https://gitlab.com/OSEGermany/oh-tsdc/-/blob/master/README.md
type TechnologySpecificDocumentationCriteria struct {
	ID string `json:"id"`
	// The human readable identifier of the standard (lowercased name). For example: "mec".
	Xid string `json:"xid"`
	// The nice name of the criteria. For example: "MEC".
	Name string `json:"name"`
	// An optional comment for the criteria.
	Comment *string `json:"comment"`
	// The URI to a document stating the corresponding requirements.
	RequirementsURI *string `json:"requirementsUri"`
	// A list of components that meet the criteria.
	Components          []*Component              `json:"components"`
	ComponentsAggregate *ComponentAggregateResult `json:"componentsAggregate"`
}

func (TechnologySpecificDocumentationCriteria) IsNode() {}

type TechnologySpecificDocumentationCriteriaAggregateResult struct {
	Count              *int64  `json:"count"`
	XidMin             *string `json:"xidMin"`
	XidMax             *string `json:"xidMax"`
	NameMin            *string `json:"nameMin"`
	NameMax            *string `json:"nameMax"`
	CommentMin         *string `json:"commentMin"`
	CommentMax         *string `json:"commentMax"`
	RequirementsURIMin *string `json:"requirementsUriMin"`
	RequirementsURIMax *string `json:"requirementsUriMax"`
}

type TechnologySpecificDocumentationCriteriaFilter struct {
	ID   []string                                            `json:"id,omitempty"`
	Xid  *StringHashFilter                                   `json:"xid,omitempty"`
	Name *StringRegExpFilterStringTermFilter                 `json:"name,omitempty"`
	Has  []*TechnologySpecificDocumentationCriteriaHasFilter `json:"has,omitempty"`
	And  []*TechnologySpecificDocumentationCriteriaFilter    `json:"and,omitempty"`
	Or   []*TechnologySpecificDocumentationCriteriaFilter    `json:"or,omitempty"`
	Not  *TechnologySpecificDocumentationCriteriaFilter      `json:"not,omitempty"`
}

type TechnologySpecificDocumentationCriteriaOrder struct {
	Asc  *TechnologySpecificDocumentationCriteriaOrderable `json:"asc,omitempty"`
	Desc *TechnologySpecificDocumentationCriteriaOrderable `json:"desc,omitempty"`
	Then *TechnologySpecificDocumentationCriteriaOrder     `json:"then,omitempty"`
}

type TechnologySpecificDocumentationCriteriaPatch struct {
	// The human readable identifier of the standard (lowercased name). For example: "mec".
	Xid *string `json:"xid,omitempty"`
	// The nice name of the criteria. For example: "MEC".
	Name *string `json:"name,omitempty"`
	// An optional comment for the criteria.
	Comment *string `json:"comment,omitempty"`
	// The URI to a document stating the corresponding requirements.
	RequirementsURI *string         `json:"requirementsUri,omitempty"`
	Components      []*ComponentRef `json:"components,omitempty"`
}

type TechnologySpecificDocumentationCriteriaRef struct {
	ID *string `json:"id,omitempty"`
	// The human readable identifier of the standard (lowercased name). For example: "mec".
	Xid *string `json:"xid,omitempty"`
	// The nice name of the criteria. For example: "MEC".
	Name *string `json:"name,omitempty"`
	// An optional comment for the criteria.
	Comment *string `json:"comment,omitempty"`
	// The URI to a document stating the corresponding requirements.
	RequirementsURI *string         `json:"requirementsUri,omitempty"`
	Components      []*ComponentRef `json:"components,omitempty"`
}

type UpdateBoundingBoxDimensionsInput struct {
	Filter BoundingBoxDimensionsFilter `json:"filter"`
	Set    *BoundingBoxDimensionsPatch `json:"set,omitempty"`
	Remove *BoundingBoxDimensionsPatch `json:"remove,omitempty"`
}

type UpdateBoundingBoxDimensionsPayload struct {
	BoundingBoxDimensions []*BoundingBoxDimensions `json:"boundingBoxDimensions"`
	NumUids               *int64                   `json:"numUids"`
}

type UpdateCategoryInput struct {
	Filter CategoryFilter `json:"filter"`
	Set    *CategoryPatch `json:"set,omitempty"`
	Remove *CategoryPatch `json:"remove,omitempty"`
}

type UpdateCategoryPayload struct {
	Category []*Category `json:"category"`
	NumUids  *int64      `json:"numUids"`
}

type UpdateComponentInput struct {
	Filter ComponentFilter `json:"filter"`
	Set    *ComponentPatch `json:"set,omitempty"`
	Remove *ComponentPatch `json:"remove,omitempty"`
}

type UpdateComponentPayload struct {
	Component []*Component `json:"component"`
	NumUids   *int64       `json:"numUids"`
}

type UpdateCrawlerMetaInput struct {
	Filter CrawlerMetaFilter `json:"filter"`
	Set    *CrawlerMetaPatch `json:"set,omitempty"`
	Remove *CrawlerMetaPatch `json:"remove,omitempty"`
}

type UpdateCrawlerMetaPayload struct {
	CrawlerMeta []CrawlerMeta `json:"crawlerMeta"`
	NumUids     *int64        `json:"numUids"`
}

type UpdateDatabaseInput struct {
	Filter DatabaseFilter `json:"filter"`
	Set    *DatabasePatch `json:"set,omitempty"`
	Remove *DatabasePatch `json:"remove,omitempty"`
}

type UpdateDatabasePayload struct {
	Database []*Database `json:"database"`
	NumUids  *int64      `json:"numUids"`
}

type UpdateFileInput struct {
	Filter FileFilter `json:"filter"`
	Set    *FilePatch `json:"set,omitempty"`
	Remove *FilePatch `json:"remove,omitempty"`
}

type UpdateFilePayload struct {
	File    []*File `json:"file"`
	NumUids *int64  `json:"numUids"`
}

type UpdateFloatVInput struct {
	Filter FloatVFilter `json:"filter"`
	Set    *FloatVPatch `json:"set,omitempty"`
	Remove *FloatVPatch `json:"remove,omitempty"`
}

type UpdateFloatVPayload struct {
	FloatV  []*FloatV `json:"floatV"`
	NumUids *int64    `json:"numUids"`
}

type UpdateGroupInput struct {
	Filter GroupFilter `json:"filter"`
	Set    *GroupPatch `json:"set,omitempty"`
	Remove *GroupPatch `json:"remove,omitempty"`
}

type UpdateGroupPayload struct {
	Group   []*Group `json:"group"`
	NumUids *int64   `json:"numUids"`
}

type UpdateHostInput struct {
	Filter HostFilter `json:"filter"`
	Set    *HostPatch `json:"set,omitempty"`
	Remove *HostPatch `json:"remove,omitempty"`
}

type UpdateHostPayload struct {
	Host    []*Host `json:"host"`
	NumUids *int64  `json:"numUids"`
}

type UpdateKeyValueInput struct {
	Filter KeyValueFilter `json:"filter"`
	Set    *KeyValuePatch `json:"set,omitempty"`
	Remove *KeyValuePatch `json:"remove,omitempty"`
}

type UpdateKeyValuePayload struct {
	KeyValue []*KeyValue `json:"keyValue"`
	NumUids  *int64      `json:"numUids"`
}

type UpdateLicenseInput struct {
	Filter LicenseFilter `json:"filter"`
	Set    *LicensePatch `json:"set,omitempty"`
	Remove *LicensePatch `json:"remove,omitempty"`
}

type UpdateLicensePayload struct {
	License []*License `json:"license"`
	NumUids *int64     `json:"numUids"`
}

type UpdateManufacturingProcessInput struct {
	Filter ManufacturingProcessFilter `json:"filter"`
	Set    *ManufacturingProcessPatch `json:"set,omitempty"`
	Remove *ManufacturingProcessPatch `json:"remove,omitempty"`
}

type UpdateManufacturingProcessPayload struct {
	ManufacturingProcess []*ManufacturingProcess `json:"manufacturingProcess"`
	NumUids              *int64                  `json:"numUids"`
}

type UpdateMaterialInput struct {
	Filter MaterialFilter `json:"filter"`
	Set    *MaterialPatch `json:"set,omitempty"`
	Remove *MaterialPatch `json:"remove,omitempty"`
}

type UpdateMaterialPayload struct {
	Material []*Material `json:"material"`
	NumUids  *int64      `json:"numUids"`
}

type UpdateOpenSCADDimensionsInput struct {
	Filter OpenSCADDimensionsFilter `json:"filter"`
	Set    *OpenSCADDimensionsPatch `json:"set,omitempty"`
	Remove *OpenSCADDimensionsPatch `json:"remove,omitempty"`
}

type UpdateOpenSCADDimensionsPayload struct {
	OpenSCADDimensions []*OpenSCADDimensions `json:"openSCADDimensions"`
	NumUids            *int64                `json:"numUids"`
}

type UpdateProductInput struct {
	Filter ProductFilter `json:"filter"`
	Set    *ProductPatch `json:"set,omitempty"`
	Remove *ProductPatch `json:"remove,omitempty"`
}

type UpdateProductPayload struct {
	Product []*Product `json:"product"`
	NumUids *int64     `json:"numUids"`
}

type UpdateRepositoryInput struct {
	Filter RepositoryFilter `json:"filter"`
	Set    *RepositoryPatch `json:"set,omitempty"`
	Remove *RepositoryPatch `json:"remove,omitempty"`
}

type UpdateRepositoryPayload struct {
	Repository []*Repository `json:"repository"`
	NumUids    *int64        `json:"numUids"`
}

type UpdateSoftwareInput struct {
	Filter SoftwareFilter `json:"filter"`
	Set    *SoftwarePatch `json:"set,omitempty"`
	Remove *SoftwarePatch `json:"remove,omitempty"`
}

type UpdateSoftwarePayload struct {
	Software []*Software `json:"software"`
	NumUids  *int64      `json:"numUids"`
}

type UpdateStringVInput struct {
	Filter StringVFilter `json:"filter"`
	Set    *StringVPatch `json:"set,omitempty"`
	Remove *StringVPatch `json:"remove,omitempty"`
}

type UpdateStringVPayload struct {
	StringV []*StringV `json:"stringV"`
	NumUids *int64     `json:"numUids"`
}

type UpdateTagInput struct {
	Filter TagFilter `json:"filter"`
	Set    *TagPatch `json:"set,omitempty"`
	Remove *TagPatch `json:"remove,omitempty"`
}

type UpdateTagPayload struct {
	Tag     []*Tag `json:"tag"`
	NumUids *int64 `json:"numUids"`
}

type UpdateTechnicalStandardInput struct {
	Filter TechnicalStandardFilter `json:"filter"`
	Set    *TechnicalStandardPatch `json:"set,omitempty"`
	Remove *TechnicalStandardPatch `json:"remove,omitempty"`
}

type UpdateTechnicalStandardPayload struct {
	TechnicalStandard []*TechnicalStandard `json:"technicalStandard"`
	NumUids           *int64               `json:"numUids"`
}

type UpdateTechnologySpecificDocumentationCriteriaInput struct {
	Filter TechnologySpecificDocumentationCriteriaFilter `json:"filter"`
	Set    *TechnologySpecificDocumentationCriteriaPatch `json:"set,omitempty"`
	Remove *TechnologySpecificDocumentationCriteriaPatch `json:"remove,omitempty"`
}

type UpdateTechnologySpecificDocumentationCriteriaPayload struct {
	TechnologySpecificDocumentationCriteria []*TechnologySpecificDocumentationCriteria `json:"technologySpecificDocumentationCriteria"`
	NumUids                                 *int64                                     `json:"numUids"`
}

type UpdateUserInput struct {
	Filter UserFilter `json:"filter"`
	Set    *UserPatch `json:"set,omitempty"`
	Remove *UserPatch `json:"remove,omitempty"`
}

type UpdateUserOrGroupInput struct {
	Filter UserOrGroupFilter `json:"filter"`
	Set    *UserOrGroupPatch `json:"set,omitempty"`
	Remove *UserOrGroupPatch `json:"remove,omitempty"`
}

type UpdateUserOrGroupPayload struct {
	UserOrGroup []UserOrGroup `json:"userOrGroup"`
	NumUids     *int64        `json:"numUids"`
}

type UpdateUserPayload struct {
	User    []*User `json:"user"`
	NumUids *int64  `json:"numUids"`
}

type User struct {
	Xid      string     `json:"xid"`
	Host     Host       `json:"host"`
	Name     string     `json:"name"`
	FullName *string    `json:"fullName"`
	Email    *string    `json:"email"`
	Avatar   *File      `json:"avatar"`
	URL      *string    `json:"url"`
	MemberOf []*Group   `json:"memberOf"`
	Products []*Product `json:"products"`
	ID       string     `json:"id"`
	// Localization of the user.
	Locale            *string                 `json:"locale"`
	MemberOfAggregate *GroupAggregateResult   `json:"memberOfAggregate"`
	ProductsAggregate *ProductAggregateResult `json:"productsAggregate"`
}

func (User) IsNode()        {}
func (User) IsUserOrGroup() {}

type UserAggregateResult struct {
	Count       *int64  `json:"count"`
	XidMin      *string `json:"xidMin"`
	XidMax      *string `json:"xidMax"`
	NameMin     *string `json:"nameMin"`
	NameMax     *string `json:"nameMax"`
	FullNameMin *string `json:"fullNameMin"`
	FullNameMax *string `json:"fullNameMax"`
	EmailMin    *string `json:"emailMin"`
	EmailMax    *string `json:"emailMax"`
	URLMin      *string `json:"urlMin"`
	URLMax      *string `json:"urlMax"`
	LocaleMin   *string `json:"localeMin"`
	LocaleMax   *string `json:"localeMax"`
}

type UserFilter struct {
	Xid      *StringHashFilter                   `json:"xid,omitempty"`
	Name     *StringRegExpFilterStringTermFilter `json:"name,omitempty"`
	FullName *StringRegExpFilterStringTermFilter `json:"fullName,omitempty"`
	Email    *StringRegExpFilterStringTermFilter `json:"email,omitempty"`
	ID       []string                            `json:"id,omitempty"`
	Has      []*UserHasFilter                    `json:"has,omitempty"`
	And      []*UserFilter                       `json:"and,omitempty"`
	Or       []*UserFilter                       `json:"or,omitempty"`
	Not      *UserFilter                         `json:"not,omitempty"`
}

type UserOrGroupAggregateResult struct {
	Count       *int64  `json:"count"`
	XidMin      *string `json:"xidMin"`
	XidMax      *string `json:"xidMax"`
	NameMin     *string `json:"nameMin"`
	NameMax     *string `json:"nameMax"`
	FullNameMin *string `json:"fullNameMin"`
	FullNameMax *string `json:"fullNameMax"`
	EmailMin    *string `json:"emailMin"`
	EmailMax    *string `json:"emailMax"`
	URLMin      *string `json:"urlMin"`
	URLMax      *string `json:"urlMax"`
}

type UserOrGroupFilter struct {
	ID       []string                            `json:"id,omitempty"`
	Xid      *StringHashFilter                   `json:"xid,omitempty"`
	Name     *StringRegExpFilterStringTermFilter `json:"name,omitempty"`
	FullName *StringRegExpFilterStringTermFilter `json:"fullName,omitempty"`
	Email    *StringRegExpFilterStringTermFilter `json:"email,omitempty"`
	Has      []*UserOrGroupHasFilter             `json:"has,omitempty"`
	And      []*UserOrGroupFilter                `json:"and,omitempty"`
	Or       []*UserOrGroupFilter                `json:"or,omitempty"`
	Not      *UserOrGroupFilter                  `json:"not,omitempty"`
}

type UserOrGroupOrder struct {
	Asc  *UserOrGroupOrderable `json:"asc,omitempty"`
	Desc *UserOrGroupOrderable `json:"desc,omitempty"`
	Then *UserOrGroupOrder     `json:"then,omitempty"`
}

type UserOrGroupPatch struct {
	//  Unique human readable identifier of the user or group in the format: `domain.tld/owner`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg`
	// - `wikifactory.com/@aisbergg`
	Xid  *string  `json:"xid,omitempty"`
	Host *HostRef `json:"host,omitempty"`
	// Name of the user or group as used on the host platform.
	Name *string `json:"name,omitempty"`
	// Full name of the person.
	FullName *string `json:"fullName,omitempty"`
	// Email address of the user or group.
	Email  *string  `json:"email,omitempty"`
	Avatar *FileRef `json:"avatar,omitempty"`
	// URL to the user or groups profile on the host platform.
	URL      *string       `json:"url,omitempty"`
	MemberOf []*GroupRef   `json:"memberOf,omitempty"`
	Products []*ProductRef `json:"products,omitempty"`
}

type UserOrGroupRef struct {
	// ID of the object.
	ID *string `json:"id,omitempty"`
	//  Unique human readable identifier of the user or group in the format: `domain.tld/owner`. Each part is path escaped. A single dash '-' denotes an empty part. Examples:
	// - `github.com/aisbergg`
	// - `wikifactory.com/@aisbergg`
	Xid *string `json:"xid,omitempty"`
}

type UserOrder struct {
	Asc  *UserOrderable `json:"asc,omitempty"`
	Desc *UserOrderable `json:"desc,omitempty"`
	Then *UserOrder     `json:"then,omitempty"`
}

type UserPatch struct {
	Xid      *string       `json:"xid,omitempty"`
	Host     *HostRef      `json:"host,omitempty"`
	Name     *string       `json:"name,omitempty"`
	FullName *string       `json:"fullName,omitempty"`
	Email    *string       `json:"email,omitempty"`
	Avatar   *FileRef      `json:"avatar,omitempty"`
	URL      *string       `json:"url,omitempty"`
	MemberOf []*GroupRef   `json:"memberOf,omitempty"`
	Products []*ProductRef `json:"products,omitempty"`
	// Localization of the user.
	Locale *string `json:"locale,omitempty"`
}

type UserRef struct {
	ID       *string       `json:"id,omitempty"`
	Xid      *string       `json:"xid,omitempty"`
	Host     *HostRef      `json:"host,omitempty"`
	Name     *string       `json:"name,omitempty"`
	FullName *string       `json:"fullName,omitempty"`
	Email    *string       `json:"email,omitempty"`
	Avatar   *FileRef      `json:"avatar,omitempty"`
	URL      *string       `json:"url,omitempty"`
	MemberOf []*GroupRef   `json:"memberOf,omitempty"`
	Products []*ProductRef `json:"products,omitempty"`
	// Localization of the user.
	Locale *string `json:"locale,omitempty"`
}

type WithinFilter struct {
	Polygon PolygonRef `json:"polygon"`
}

type BoundingBoxDimensionsHasFilter string

const (
	BoundingBoxDimensionsHasFilterHeight BoundingBoxDimensionsHasFilter = "height"
	BoundingBoxDimensionsHasFilterWidth  BoundingBoxDimensionsHasFilter = "width"
	BoundingBoxDimensionsHasFilterDepth  BoundingBoxDimensionsHasFilter = "depth"
)

var AllBoundingBoxDimensionsHasFilter = []BoundingBoxDimensionsHasFilter{
	BoundingBoxDimensionsHasFilterHeight,
	BoundingBoxDimensionsHasFilterWidth,
	BoundingBoxDimensionsHasFilterDepth,
}

func (e BoundingBoxDimensionsHasFilter) IsValid() bool {
	switch e {
	case BoundingBoxDimensionsHasFilterHeight, BoundingBoxDimensionsHasFilterWidth, BoundingBoxDimensionsHasFilterDepth:
		return true
	}
	return false
}

func (e BoundingBoxDimensionsHasFilter) String() string {
	return string(e)
}

func (e *BoundingBoxDimensionsHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BoundingBoxDimensionsHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BoundingBoxDimensionsHasFilter", str)
	}
	return nil
}

func (e BoundingBoxDimensionsHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BoundingBoxDimensionsOrderable string

const (
	BoundingBoxDimensionsOrderableHeight BoundingBoxDimensionsOrderable = "height"
	BoundingBoxDimensionsOrderableWidth  BoundingBoxDimensionsOrderable = "width"
	BoundingBoxDimensionsOrderableDepth  BoundingBoxDimensionsOrderable = "depth"
)

var AllBoundingBoxDimensionsOrderable = []BoundingBoxDimensionsOrderable{
	BoundingBoxDimensionsOrderableHeight,
	BoundingBoxDimensionsOrderableWidth,
	BoundingBoxDimensionsOrderableDepth,
}

func (e BoundingBoxDimensionsOrderable) IsValid() bool {
	switch e {
	case BoundingBoxDimensionsOrderableHeight, BoundingBoxDimensionsOrderableWidth, BoundingBoxDimensionsOrderableDepth:
		return true
	}
	return false
}

func (e BoundingBoxDimensionsOrderable) String() string {
	return string(e)
}

func (e *BoundingBoxDimensionsOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BoundingBoxDimensionsOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BoundingBoxDimensionsOrderable", str)
	}
	return nil
}

func (e BoundingBoxDimensionsOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CategoryHasFilter string

const (
	CategoryHasFilterXid         CategoryHasFilter = "xid"
	CategoryHasFilterFullName    CategoryHasFilter = "fullName"
	CategoryHasFilterName        CategoryHasFilter = "name"
	CategoryHasFilterDescription CategoryHasFilter = "description"
	CategoryHasFilterParent      CategoryHasFilter = "parent"
	CategoryHasFilterChildren    CategoryHasFilter = "children"
	CategoryHasFilterProducts    CategoryHasFilter = "products"
)

var AllCategoryHasFilter = []CategoryHasFilter{
	CategoryHasFilterXid,
	CategoryHasFilterFullName,
	CategoryHasFilterName,
	CategoryHasFilterDescription,
	CategoryHasFilterParent,
	CategoryHasFilterChildren,
	CategoryHasFilterProducts,
}

func (e CategoryHasFilter) IsValid() bool {
	switch e {
	case CategoryHasFilterXid, CategoryHasFilterFullName, CategoryHasFilterName, CategoryHasFilterDescription, CategoryHasFilterParent, CategoryHasFilterChildren, CategoryHasFilterProducts:
		return true
	}
	return false
}

func (e CategoryHasFilter) String() string {
	return string(e)
}

func (e *CategoryHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CategoryHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CategoryHasFilter", str)
	}
	return nil
}

func (e CategoryHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CategoryOrderable string

const (
	CategoryOrderableXid         CategoryOrderable = "xid"
	CategoryOrderableFullName    CategoryOrderable = "fullName"
	CategoryOrderableName        CategoryOrderable = "name"
	CategoryOrderableDescription CategoryOrderable = "description"
)

var AllCategoryOrderable = []CategoryOrderable{
	CategoryOrderableXid,
	CategoryOrderableFullName,
	CategoryOrderableName,
	CategoryOrderableDescription,
}

func (e CategoryOrderable) IsValid() bool {
	switch e {
	case CategoryOrderableXid, CategoryOrderableFullName, CategoryOrderableName, CategoryOrderableDescription:
		return true
	}
	return false
}

func (e CategoryOrderable) String() string {
	return string(e)
}

func (e *CategoryOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CategoryOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CategoryOrderable", str)
	}
	return nil
}

func (e CategoryOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ComponentHasFilter string

const (
	ComponentHasFilterDiscoveredAt                ComponentHasFilter = "discoveredAt"
	ComponentHasFilterLastIndexedAt               ComponentHasFilter = "lastIndexedAt"
	ComponentHasFilterDataSource                  ComponentHasFilter = "dataSource"
	ComponentHasFilterXid                         ComponentHasFilter = "xid"
	ComponentHasFilterName                        ComponentHasFilter = "name"
	ComponentHasFilterDescription                 ComponentHasFilter = "description"
	ComponentHasFilterVersion                     ComponentHasFilter = "version"
	ComponentHasFilterCreatedAt                   ComponentHasFilter = "createdAt"
	ComponentHasFilterReleases                    ComponentHasFilter = "releases"
	ComponentHasFilterIsLatest                    ComponentHasFilter = "isLatest"
	ComponentHasFilterRepository                  ComponentHasFilter = "repository"
	ComponentHasFilterLicense                     ComponentHasFilter = "license"
	ComponentHasFilterAdditionalLicenses          ComponentHasFilter = "additionalLicenses"
	ComponentHasFilterLicensor                    ComponentHasFilter = "licensor"
	ComponentHasFilterDocumentationLanguage       ComponentHasFilter = "documentationLanguage"
	ComponentHasFilterTechnologyReadinessLevel    ComponentHasFilter = "technologyReadinessLevel"
	ComponentHasFilterDocumentationReadinessLevel ComponentHasFilter = "documentationReadinessLevel"
	ComponentHasFilterAttestation                 ComponentHasFilter = "attestation"
	ComponentHasFilterPublication                 ComponentHasFilter = "publication"
	ComponentHasFilterIssues                      ComponentHasFilter = "issues"
	ComponentHasFilterCompliesWith                ComponentHasFilter = "compliesWith"
	ComponentHasFilterCpcPatentClass              ComponentHasFilter = "cpcPatentClass"
	ComponentHasFilterTsdc                        ComponentHasFilter = "tsdc"
	ComponentHasFilterComponents                  ComponentHasFilter = "components"
	ComponentHasFilterSoftware                    ComponentHasFilter = "software"
	ComponentHasFilterImage                       ComponentHasFilter = "image"
	ComponentHasFilterReadme                      ComponentHasFilter = "readme"
	ComponentHasFilterContributionGuide           ComponentHasFilter = "contributionGuide"
	ComponentHasFilterBom                         ComponentHasFilter = "bom"
	ComponentHasFilterManufacturingInstructions   ComponentHasFilter = "manufacturingInstructions"
	ComponentHasFilterUserManual                  ComponentHasFilter = "userManual"
	ComponentHasFilterProduct                     ComponentHasFilter = "product"
	ComponentHasFilterUsedIn                      ComponentHasFilter = "usedIn"
	ComponentHasFilterSource                      ComponentHasFilter = "source"
	ComponentHasFilterExport                      ComponentHasFilter = "export"
	ComponentHasFilterAuxiliary                   ComponentHasFilter = "auxiliary"
	ComponentHasFilterOrganization                ComponentHasFilter = "organization"
	ComponentHasFilterMass                        ComponentHasFilter = "mass"
	ComponentHasFilterOuterDimensions             ComponentHasFilter = "outerDimensions"
	ComponentHasFilterMaterial                    ComponentHasFilter = "material"
	ComponentHasFilterManufacturingProcess        ComponentHasFilter = "manufacturingProcess"
	ComponentHasFilterProductionMetadata          ComponentHasFilter = "productionMetadata"
)

var AllComponentHasFilter = []ComponentHasFilter{
	ComponentHasFilterDiscoveredAt,
	ComponentHasFilterLastIndexedAt,
	ComponentHasFilterDataSource,
	ComponentHasFilterXid,
	ComponentHasFilterName,
	ComponentHasFilterDescription,
	ComponentHasFilterVersion,
	ComponentHasFilterCreatedAt,
	ComponentHasFilterReleases,
	ComponentHasFilterIsLatest,
	ComponentHasFilterRepository,
	ComponentHasFilterLicense,
	ComponentHasFilterAdditionalLicenses,
	ComponentHasFilterLicensor,
	ComponentHasFilterDocumentationLanguage,
	ComponentHasFilterTechnologyReadinessLevel,
	ComponentHasFilterDocumentationReadinessLevel,
	ComponentHasFilterAttestation,
	ComponentHasFilterPublication,
	ComponentHasFilterIssues,
	ComponentHasFilterCompliesWith,
	ComponentHasFilterCpcPatentClass,
	ComponentHasFilterTsdc,
	ComponentHasFilterComponents,
	ComponentHasFilterSoftware,
	ComponentHasFilterImage,
	ComponentHasFilterReadme,
	ComponentHasFilterContributionGuide,
	ComponentHasFilterBom,
	ComponentHasFilterManufacturingInstructions,
	ComponentHasFilterUserManual,
	ComponentHasFilterProduct,
	ComponentHasFilterUsedIn,
	ComponentHasFilterSource,
	ComponentHasFilterExport,
	ComponentHasFilterAuxiliary,
	ComponentHasFilterOrganization,
	ComponentHasFilterMass,
	ComponentHasFilterOuterDimensions,
	ComponentHasFilterMaterial,
	ComponentHasFilterManufacturingProcess,
	ComponentHasFilterProductionMetadata,
}

func (e ComponentHasFilter) IsValid() bool {
	switch e {
	case ComponentHasFilterDiscoveredAt, ComponentHasFilterLastIndexedAt, ComponentHasFilterDataSource, ComponentHasFilterXid, ComponentHasFilterName, ComponentHasFilterDescription, ComponentHasFilterVersion, ComponentHasFilterCreatedAt, ComponentHasFilterReleases, ComponentHasFilterIsLatest, ComponentHasFilterRepository, ComponentHasFilterLicense, ComponentHasFilterAdditionalLicenses, ComponentHasFilterLicensor, ComponentHasFilterDocumentationLanguage, ComponentHasFilterTechnologyReadinessLevel, ComponentHasFilterDocumentationReadinessLevel, ComponentHasFilterAttestation, ComponentHasFilterPublication, ComponentHasFilterIssues, ComponentHasFilterCompliesWith, ComponentHasFilterCpcPatentClass, ComponentHasFilterTsdc, ComponentHasFilterComponents, ComponentHasFilterSoftware, ComponentHasFilterImage, ComponentHasFilterReadme, ComponentHasFilterContributionGuide, ComponentHasFilterBom, ComponentHasFilterManufacturingInstructions, ComponentHasFilterUserManual, ComponentHasFilterProduct, ComponentHasFilterUsedIn, ComponentHasFilterSource, ComponentHasFilterExport, ComponentHasFilterAuxiliary, ComponentHasFilterOrganization, ComponentHasFilterMass, ComponentHasFilterOuterDimensions, ComponentHasFilterMaterial, ComponentHasFilterManufacturingProcess, ComponentHasFilterProductionMetadata:
		return true
	}
	return false
}

func (e ComponentHasFilter) String() string {
	return string(e)
}

func (e *ComponentHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComponentHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComponentHasFilter", str)
	}
	return nil
}

func (e ComponentHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ComponentOrderable string

const (
	ComponentOrderableDiscoveredAt          ComponentOrderable = "discoveredAt"
	ComponentOrderableLastIndexedAt         ComponentOrderable = "lastIndexedAt"
	ComponentOrderableXid                   ComponentOrderable = "xid"
	ComponentOrderableName                  ComponentOrderable = "name"
	ComponentOrderableDescription           ComponentOrderable = "description"
	ComponentOrderableVersion               ComponentOrderable = "version"
	ComponentOrderableCreatedAt             ComponentOrderable = "createdAt"
	ComponentOrderableDocumentationLanguage ComponentOrderable = "documentationLanguage"
	ComponentOrderableAttestation           ComponentOrderable = "attestation"
	ComponentOrderablePublication           ComponentOrderable = "publication"
	ComponentOrderableIssues                ComponentOrderable = "issues"
	ComponentOrderableCpcPatentClass        ComponentOrderable = "cpcPatentClass"
	ComponentOrderableMass                  ComponentOrderable = "mass"
)

var AllComponentOrderable = []ComponentOrderable{
	ComponentOrderableDiscoveredAt,
	ComponentOrderableLastIndexedAt,
	ComponentOrderableXid,
	ComponentOrderableName,
	ComponentOrderableDescription,
	ComponentOrderableVersion,
	ComponentOrderableCreatedAt,
	ComponentOrderableDocumentationLanguage,
	ComponentOrderableAttestation,
	ComponentOrderablePublication,
	ComponentOrderableIssues,
	ComponentOrderableCpcPatentClass,
	ComponentOrderableMass,
}

func (e ComponentOrderable) IsValid() bool {
	switch e {
	case ComponentOrderableDiscoveredAt, ComponentOrderableLastIndexedAt, ComponentOrderableXid, ComponentOrderableName, ComponentOrderableDescription, ComponentOrderableVersion, ComponentOrderableCreatedAt, ComponentOrderableDocumentationLanguage, ComponentOrderableAttestation, ComponentOrderablePublication, ComponentOrderableIssues, ComponentOrderableCpcPatentClass, ComponentOrderableMass:
		return true
	}
	return false
}

func (e ComponentOrderable) String() string {
	return string(e)
}

func (e *ComponentOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComponentOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComponentOrderable", str)
	}
	return nil
}

func (e ComponentOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CrawlerMetaHasFilter string

const (
	CrawlerMetaHasFilterDiscoveredAt  CrawlerMetaHasFilter = "discoveredAt"
	CrawlerMetaHasFilterLastIndexedAt CrawlerMetaHasFilter = "lastIndexedAt"
	CrawlerMetaHasFilterDataSource    CrawlerMetaHasFilter = "dataSource"
)

var AllCrawlerMetaHasFilter = []CrawlerMetaHasFilter{
	CrawlerMetaHasFilterDiscoveredAt,
	CrawlerMetaHasFilterLastIndexedAt,
	CrawlerMetaHasFilterDataSource,
}

func (e CrawlerMetaHasFilter) IsValid() bool {
	switch e {
	case CrawlerMetaHasFilterDiscoveredAt, CrawlerMetaHasFilterLastIndexedAt, CrawlerMetaHasFilterDataSource:
		return true
	}
	return false
}

func (e CrawlerMetaHasFilter) String() string {
	return string(e)
}

func (e *CrawlerMetaHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CrawlerMetaHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CrawlerMetaHasFilter", str)
	}
	return nil
}

func (e CrawlerMetaHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CrawlerMetaOrderable string

const (
	CrawlerMetaOrderableDiscoveredAt  CrawlerMetaOrderable = "discoveredAt"
	CrawlerMetaOrderableLastIndexedAt CrawlerMetaOrderable = "lastIndexedAt"
)

var AllCrawlerMetaOrderable = []CrawlerMetaOrderable{
	CrawlerMetaOrderableDiscoveredAt,
	CrawlerMetaOrderableLastIndexedAt,
}

func (e CrawlerMetaOrderable) IsValid() bool {
	switch e {
	case CrawlerMetaOrderableDiscoveredAt, CrawlerMetaOrderableLastIndexedAt:
		return true
	}
	return false
}

func (e CrawlerMetaOrderable) String() string {
	return string(e)
}

func (e *CrawlerMetaOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CrawlerMetaOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CrawlerMetaOrderable", str)
	}
	return nil
}

func (e CrawlerMetaOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DatabaseHasFilter string

const (
	DatabaseHasFilterVersion DatabaseHasFilter = "version"
)

var AllDatabaseHasFilter = []DatabaseHasFilter{
	DatabaseHasFilterVersion,
}

func (e DatabaseHasFilter) IsValid() bool {
	switch e {
	case DatabaseHasFilterVersion:
		return true
	}
	return false
}

func (e DatabaseHasFilter) String() string {
	return string(e)
}

func (e *DatabaseHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DatabaseHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DatabaseHasFilter", str)
	}
	return nil
}

func (e DatabaseHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DatabaseOrderable string

const (
	DatabaseOrderableVersion DatabaseOrderable = "version"
)

var AllDatabaseOrderable = []DatabaseOrderable{
	DatabaseOrderableVersion,
}

func (e DatabaseOrderable) IsValid() bool {
	switch e {
	case DatabaseOrderableVersion:
		return true
	}
	return false
}

func (e DatabaseOrderable) String() string {
	return string(e)
}

func (e *DatabaseOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DatabaseOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DatabaseOrderable", str)
	}
	return nil
}

func (e DatabaseOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DgraphIndex string

const (
	DgraphIndexInt      DgraphIndex = "int"
	DgraphIndexInt64    DgraphIndex = "int64"
	DgraphIndexFloat    DgraphIndex = "float"
	DgraphIndexBool     DgraphIndex = "bool"
	DgraphIndexHash     DgraphIndex = "hash"
	DgraphIndexExact    DgraphIndex = "exact"
	DgraphIndexTerm     DgraphIndex = "term"
	DgraphIndexFulltext DgraphIndex = "fulltext"
	DgraphIndexTrigram  DgraphIndex = "trigram"
	DgraphIndexRegexp   DgraphIndex = "regexp"
	DgraphIndexYear     DgraphIndex = "year"
	DgraphIndexMonth    DgraphIndex = "month"
	DgraphIndexDay      DgraphIndex = "day"
	DgraphIndexHour     DgraphIndex = "hour"
	DgraphIndexGeo      DgraphIndex = "geo"
)

var AllDgraphIndex = []DgraphIndex{
	DgraphIndexInt,
	DgraphIndexInt64,
	DgraphIndexFloat,
	DgraphIndexBool,
	DgraphIndexHash,
	DgraphIndexExact,
	DgraphIndexTerm,
	DgraphIndexFulltext,
	DgraphIndexTrigram,
	DgraphIndexRegexp,
	DgraphIndexYear,
	DgraphIndexMonth,
	DgraphIndexDay,
	DgraphIndexHour,
	DgraphIndexGeo,
}

func (e DgraphIndex) IsValid() bool {
	switch e {
	case DgraphIndexInt, DgraphIndexInt64, DgraphIndexFloat, DgraphIndexBool, DgraphIndexHash, DgraphIndexExact, DgraphIndexTerm, DgraphIndexFulltext, DgraphIndexTrigram, DgraphIndexRegexp, DgraphIndexYear, DgraphIndexMonth, DgraphIndexDay, DgraphIndexHour, DgraphIndexGeo:
		return true
	}
	return false
}

func (e DgraphIndex) String() string {
	return string(e)
}

func (e *DgraphIndex) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DgraphIndex(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DgraphIndex", str)
	}
	return nil
}

func (e DgraphIndex) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The documentation readiness levels of components.
type DocumentationReadinessLevel string

const (
	DocumentationReadinessLevelUndetermined DocumentationReadinessLevel = "UNDETERMINED"
	DocumentationReadinessLevelOdrl1        DocumentationReadinessLevel = "ODRL_1"
	DocumentationReadinessLevelOdrl2        DocumentationReadinessLevel = "ODRL_2"
	DocumentationReadinessLevelOdrl3        DocumentationReadinessLevel = "ODRL_3"
	DocumentationReadinessLevelOdrl4        DocumentationReadinessLevel = "ODRL_4"
	DocumentationReadinessLevelOdrl5        DocumentationReadinessLevel = "ODRL_5"
)

var AllDocumentationReadinessLevel = []DocumentationReadinessLevel{
	DocumentationReadinessLevelUndetermined,
	DocumentationReadinessLevelOdrl1,
	DocumentationReadinessLevelOdrl2,
	DocumentationReadinessLevelOdrl3,
	DocumentationReadinessLevelOdrl4,
	DocumentationReadinessLevelOdrl5,
}

func (e DocumentationReadinessLevel) IsValid() bool {
	switch e {
	case DocumentationReadinessLevelUndetermined, DocumentationReadinessLevelOdrl1, DocumentationReadinessLevelOdrl2, DocumentationReadinessLevelOdrl3, DocumentationReadinessLevelOdrl4, DocumentationReadinessLevelOdrl5:
		return true
	}
	return false
}

func (e DocumentationReadinessLevel) String() string {
	return string(e)
}

func (e *DocumentationReadinessLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DocumentationReadinessLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DocumentationReadinessLevel", str)
	}
	return nil
}

func (e DocumentationReadinessLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileHasFilter string

const (
	FileHasFilterDiscoveredAt  FileHasFilter = "discoveredAt"
	FileHasFilterLastIndexedAt FileHasFilter = "lastIndexedAt"
	FileHasFilterDataSource    FileHasFilter = "dataSource"
	FileHasFilterXid           FileHasFilter = "xid"
	FileHasFilterName          FileHasFilter = "name"
	FileHasFilterPath          FileHasFilter = "path"
	FileHasFilterMimeType      FileHasFilter = "mimeType"
	FileHasFilterURL           FileHasFilter = "url"
	FileHasFilterCreatedAt     FileHasFilter = "createdAt"
)

var AllFileHasFilter = []FileHasFilter{
	FileHasFilterDiscoveredAt,
	FileHasFilterLastIndexedAt,
	FileHasFilterDataSource,
	FileHasFilterXid,
	FileHasFilterName,
	FileHasFilterPath,
	FileHasFilterMimeType,
	FileHasFilterURL,
	FileHasFilterCreatedAt,
}

func (e FileHasFilter) IsValid() bool {
	switch e {
	case FileHasFilterDiscoveredAt, FileHasFilterLastIndexedAt, FileHasFilterDataSource, FileHasFilterXid, FileHasFilterName, FileHasFilterPath, FileHasFilterMimeType, FileHasFilterURL, FileHasFilterCreatedAt:
		return true
	}
	return false
}

func (e FileHasFilter) String() string {
	return string(e)
}

func (e *FileHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileHasFilter", str)
	}
	return nil
}

func (e FileHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FileOrderable string

const (
	FileOrderableDiscoveredAt  FileOrderable = "discoveredAt"
	FileOrderableLastIndexedAt FileOrderable = "lastIndexedAt"
	FileOrderableXid           FileOrderable = "xid"
	FileOrderableName          FileOrderable = "name"
	FileOrderablePath          FileOrderable = "path"
	FileOrderableMimeType      FileOrderable = "mimeType"
	FileOrderableURL           FileOrderable = "url"
	FileOrderableCreatedAt     FileOrderable = "createdAt"
)

var AllFileOrderable = []FileOrderable{
	FileOrderableDiscoveredAt,
	FileOrderableLastIndexedAt,
	FileOrderableXid,
	FileOrderableName,
	FileOrderablePath,
	FileOrderableMimeType,
	FileOrderableURL,
	FileOrderableCreatedAt,
}

func (e FileOrderable) IsValid() bool {
	switch e {
	case FileOrderableDiscoveredAt, FileOrderableLastIndexedAt, FileOrderableXid, FileOrderableName, FileOrderablePath, FileOrderableMimeType, FileOrderableURL, FileOrderableCreatedAt:
		return true
	}
	return false
}

func (e FileOrderable) String() string {
	return string(e)
}

func (e *FileOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FileOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FileOrderable", str)
	}
	return nil
}

func (e FileOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FloatVHasFilter string

const (
	FloatVHasFilterValue FloatVHasFilter = "value"
)

var AllFloatVHasFilter = []FloatVHasFilter{
	FloatVHasFilterValue,
}

func (e FloatVHasFilter) IsValid() bool {
	switch e {
	case FloatVHasFilterValue:
		return true
	}
	return false
}

func (e FloatVHasFilter) String() string {
	return string(e)
}

func (e *FloatVHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FloatVHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FloatVHasFilter", str)
	}
	return nil
}

func (e FloatVHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FloatVOrderable string

const (
	FloatVOrderableValue FloatVOrderable = "value"
)

var AllFloatVOrderable = []FloatVOrderable{
	FloatVOrderableValue,
}

func (e FloatVOrderable) IsValid() bool {
	switch e {
	case FloatVOrderableValue:
		return true
	}
	return false
}

func (e FloatVOrderable) String() string {
	return string(e)
}

func (e *FloatVOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FloatVOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FloatVOrderable", str)
	}
	return nil
}

func (e FloatVOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupHasFilter string

const (
	GroupHasFilterXid      GroupHasFilter = "xid"
	GroupHasFilterHost     GroupHasFilter = "host"
	GroupHasFilterName     GroupHasFilter = "name"
	GroupHasFilterFullName GroupHasFilter = "fullName"
	GroupHasFilterEmail    GroupHasFilter = "email"
	GroupHasFilterAvatar   GroupHasFilter = "avatar"
	GroupHasFilterURL      GroupHasFilter = "url"
	GroupHasFilterMemberOf GroupHasFilter = "memberOf"
	GroupHasFilterProducts GroupHasFilter = "products"
	GroupHasFilterMembers  GroupHasFilter = "members"
)

var AllGroupHasFilter = []GroupHasFilter{
	GroupHasFilterXid,
	GroupHasFilterHost,
	GroupHasFilterName,
	GroupHasFilterFullName,
	GroupHasFilterEmail,
	GroupHasFilterAvatar,
	GroupHasFilterURL,
	GroupHasFilterMemberOf,
	GroupHasFilterProducts,
	GroupHasFilterMembers,
}

func (e GroupHasFilter) IsValid() bool {
	switch e {
	case GroupHasFilterXid, GroupHasFilterHost, GroupHasFilterName, GroupHasFilterFullName, GroupHasFilterEmail, GroupHasFilterAvatar, GroupHasFilterURL, GroupHasFilterMemberOf, GroupHasFilterProducts, GroupHasFilterMembers:
		return true
	}
	return false
}

func (e GroupHasFilter) String() string {
	return string(e)
}

func (e *GroupHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupHasFilter", str)
	}
	return nil
}

func (e GroupHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroupOrderable string

const (
	GroupOrderableXid      GroupOrderable = "xid"
	GroupOrderableName     GroupOrderable = "name"
	GroupOrderableFullName GroupOrderable = "fullName"
	GroupOrderableEmail    GroupOrderable = "email"
	GroupOrderableURL      GroupOrderable = "url"
)

var AllGroupOrderable = []GroupOrderable{
	GroupOrderableXid,
	GroupOrderableName,
	GroupOrderableFullName,
	GroupOrderableEmail,
	GroupOrderableURL,
}

func (e GroupOrderable) IsValid() bool {
	switch e {
	case GroupOrderableXid, GroupOrderableName, GroupOrderableFullName, GroupOrderableEmail, GroupOrderableURL:
		return true
	}
	return false
}

func (e GroupOrderable) String() string {
	return string(e)
}

func (e *GroupOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderable", str)
	}
	return nil
}

func (e GroupOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HTTPMethod string

const (
	HTTPMethodGet    HTTPMethod = "GET"
	HTTPMethodPost   HTTPMethod = "POST"
	HTTPMethodPut    HTTPMethod = "PUT"
	HTTPMethodPatch  HTTPMethod = "PATCH"
	HTTPMethodDelete HTTPMethod = "DELETE"
)

var AllHTTPMethod = []HTTPMethod{
	HTTPMethodGet,
	HTTPMethodPost,
	HTTPMethodPut,
	HTTPMethodPatch,
	HTTPMethodDelete,
}

func (e HTTPMethod) IsValid() bool {
	switch e {
	case HTTPMethodGet, HTTPMethodPost, HTTPMethodPut, HTTPMethodPatch, HTTPMethodDelete:
		return true
	}
	return false
}

func (e HTTPMethod) String() string {
	return string(e)
}

func (e *HTTPMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HTTPMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HTTPMethod", str)
	}
	return nil
}

func (e HTTPMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HostHasFilter string

const (
	HostHasFilterDomain HostHasFilter = "domain"
	HostHasFilterName   HostHasFilter = "name"
)

var AllHostHasFilter = []HostHasFilter{
	HostHasFilterDomain,
	HostHasFilterName,
}

func (e HostHasFilter) IsValid() bool {
	switch e {
	case HostHasFilterDomain, HostHasFilterName:
		return true
	}
	return false
}

func (e HostHasFilter) String() string {
	return string(e)
}

func (e *HostHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HostHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HostHasFilter", str)
	}
	return nil
}

func (e HostHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HostOrderable string

const (
	HostOrderableDomain HostOrderable = "domain"
	HostOrderableName   HostOrderable = "name"
)

var AllHostOrderable = []HostOrderable{
	HostOrderableDomain,
	HostOrderableName,
}

func (e HostOrderable) IsValid() bool {
	switch e {
	case HostOrderableDomain, HostOrderableName:
		return true
	}
	return false
}

func (e HostOrderable) String() string {
	return string(e)
}

func (e *HostOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HostOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HostOrderable", str)
	}
	return nil
}

func (e HostOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type KeyValueHasFilter string

const (
	KeyValueHasFilterKey   KeyValueHasFilter = "key"
	KeyValueHasFilterValue KeyValueHasFilter = "value"
)

var AllKeyValueHasFilter = []KeyValueHasFilter{
	KeyValueHasFilterKey,
	KeyValueHasFilterValue,
}

func (e KeyValueHasFilter) IsValid() bool {
	switch e {
	case KeyValueHasFilterKey, KeyValueHasFilterValue:
		return true
	}
	return false
}

func (e KeyValueHasFilter) String() string {
	return string(e)
}

func (e *KeyValueHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KeyValueHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KeyValueHasFilter", str)
	}
	return nil
}

func (e KeyValueHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type KeyValueOrderable string

const (
	KeyValueOrderableKey KeyValueOrderable = "key"
)

var AllKeyValueOrderable = []KeyValueOrderable{
	KeyValueOrderableKey,
}

func (e KeyValueOrderable) IsValid() bool {
	switch e {
	case KeyValueOrderableKey:
		return true
	}
	return false
}

func (e KeyValueOrderable) String() string {
	return string(e)
}

func (e *KeyValueOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KeyValueOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KeyValueOrderable", str)
	}
	return nil
}

func (e KeyValueOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LicenseHasFilter string

const (
	LicenseHasFilterXid           LicenseHasFilter = "xid"
	LicenseHasFilterName          LicenseHasFilter = "name"
	LicenseHasFilterText          LicenseHasFilter = "text"
	LicenseHasFilterTextHTML      LicenseHasFilter = "textHTML"
	LicenseHasFilterReferenceURL  LicenseHasFilter = "referenceURL"
	LicenseHasFilterDetailsURL    LicenseHasFilter = "detailsURL"
	LicenseHasFilterType          LicenseHasFilter = "type"
	LicenseHasFilterIsSpdx        LicenseHasFilter = "isSpdx"
	LicenseHasFilterIsDeprecated  LicenseHasFilter = "isDeprecated"
	LicenseHasFilterIsOsiApproved LicenseHasFilter = "isOsiApproved"
	LicenseHasFilterIsFsfLibre    LicenseHasFilter = "isFsfLibre"
	LicenseHasFilterIsBlocked     LicenseHasFilter = "isBlocked"
)

var AllLicenseHasFilter = []LicenseHasFilter{
	LicenseHasFilterXid,
	LicenseHasFilterName,
	LicenseHasFilterText,
	LicenseHasFilterTextHTML,
	LicenseHasFilterReferenceURL,
	LicenseHasFilterDetailsURL,
	LicenseHasFilterType,
	LicenseHasFilterIsSpdx,
	LicenseHasFilterIsDeprecated,
	LicenseHasFilterIsOsiApproved,
	LicenseHasFilterIsFsfLibre,
	LicenseHasFilterIsBlocked,
}

func (e LicenseHasFilter) IsValid() bool {
	switch e {
	case LicenseHasFilterXid, LicenseHasFilterName, LicenseHasFilterText, LicenseHasFilterTextHTML, LicenseHasFilterReferenceURL, LicenseHasFilterDetailsURL, LicenseHasFilterType, LicenseHasFilterIsSpdx, LicenseHasFilterIsDeprecated, LicenseHasFilterIsOsiApproved, LicenseHasFilterIsFsfLibre, LicenseHasFilterIsBlocked:
		return true
	}
	return false
}

func (e LicenseHasFilter) String() string {
	return string(e)
}

func (e *LicenseHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseHasFilter", str)
	}
	return nil
}

func (e LicenseHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LicenseOrderable string

const (
	LicenseOrderableXid          LicenseOrderable = "xid"
	LicenseOrderableName         LicenseOrderable = "name"
	LicenseOrderableText         LicenseOrderable = "text"
	LicenseOrderableTextHTML     LicenseOrderable = "textHTML"
	LicenseOrderableReferenceURL LicenseOrderable = "referenceURL"
	LicenseOrderableDetailsURL   LicenseOrderable = "detailsURL"
)

var AllLicenseOrderable = []LicenseOrderable{
	LicenseOrderableXid,
	LicenseOrderableName,
	LicenseOrderableText,
	LicenseOrderableTextHTML,
	LicenseOrderableReferenceURL,
	LicenseOrderableDetailsURL,
}

func (e LicenseOrderable) IsValid() bool {
	switch e {
	case LicenseOrderableXid, LicenseOrderableName, LicenseOrderableText, LicenseOrderableTextHTML, LicenseOrderableReferenceURL, LicenseOrderableDetailsURL:
		return true
	}
	return false
}

func (e LicenseOrderable) String() string {
	return string(e)
}

func (e *LicenseOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseOrderable", str)
	}
	return nil
}

func (e LicenseOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The types (strength) of a licenses.
type LicenseType string

const (
	LicenseTypeUnknown    LicenseType = "UNKNOWN"
	LicenseTypeStrong     LicenseType = "STRONG"
	LicenseTypeWeak       LicenseType = "WEAK"
	LicenseTypePermissive LicenseType = "PERMISSIVE"
)

var AllLicenseType = []LicenseType{
	LicenseTypeUnknown,
	LicenseTypeStrong,
	LicenseTypeWeak,
	LicenseTypePermissive,
}

func (e LicenseType) IsValid() bool {
	switch e {
	case LicenseTypeUnknown, LicenseTypeStrong, LicenseTypeWeak, LicenseTypePermissive:
		return true
	}
	return false
}

func (e LicenseType) String() string {
	return string(e)
}

func (e *LicenseType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LicenseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LicenseType", str)
	}
	return nil
}

func (e LicenseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ManufacturingProcessHasFilter string

const (
	ManufacturingProcessHasFilterName        ManufacturingProcessHasFilter = "name"
	ManufacturingProcessHasFilterDescription ManufacturingProcessHasFilter = "description"
)

var AllManufacturingProcessHasFilter = []ManufacturingProcessHasFilter{
	ManufacturingProcessHasFilterName,
	ManufacturingProcessHasFilterDescription,
}

func (e ManufacturingProcessHasFilter) IsValid() bool {
	switch e {
	case ManufacturingProcessHasFilterName, ManufacturingProcessHasFilterDescription:
		return true
	}
	return false
}

func (e ManufacturingProcessHasFilter) String() string {
	return string(e)
}

func (e *ManufacturingProcessHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ManufacturingProcessHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ManufacturingProcessHasFilter", str)
	}
	return nil
}

func (e ManufacturingProcessHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ManufacturingProcessOrderable string

const (
	ManufacturingProcessOrderableName        ManufacturingProcessOrderable = "name"
	ManufacturingProcessOrderableDescription ManufacturingProcessOrderable = "description"
)

var AllManufacturingProcessOrderable = []ManufacturingProcessOrderable{
	ManufacturingProcessOrderableName,
	ManufacturingProcessOrderableDescription,
}

func (e ManufacturingProcessOrderable) IsValid() bool {
	switch e {
	case ManufacturingProcessOrderableName, ManufacturingProcessOrderableDescription:
		return true
	}
	return false
}

func (e ManufacturingProcessOrderable) String() string {
	return string(e)
}

func (e *ManufacturingProcessOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ManufacturingProcessOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ManufacturingProcessOrderable", str)
	}
	return nil
}

func (e ManufacturingProcessOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MaterialHasFilter string

const (
	MaterialHasFilterName        MaterialHasFilter = "name"
	MaterialHasFilterDescription MaterialHasFilter = "description"
)

var AllMaterialHasFilter = []MaterialHasFilter{
	MaterialHasFilterName,
	MaterialHasFilterDescription,
}

func (e MaterialHasFilter) IsValid() bool {
	switch e {
	case MaterialHasFilterName, MaterialHasFilterDescription:
		return true
	}
	return false
}

func (e MaterialHasFilter) String() string {
	return string(e)
}

func (e *MaterialHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MaterialHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MaterialHasFilter", str)
	}
	return nil
}

func (e MaterialHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MaterialOrderable string

const (
	MaterialOrderableName        MaterialOrderable = "name"
	MaterialOrderableDescription MaterialOrderable = "description"
)

var AllMaterialOrderable = []MaterialOrderable{
	MaterialOrderableName,
	MaterialOrderableDescription,
}

func (e MaterialOrderable) IsValid() bool {
	switch e {
	case MaterialOrderableName, MaterialOrderableDescription:
		return true
	}
	return false
}

func (e MaterialOrderable) String() string {
	return string(e)
}

func (e *MaterialOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MaterialOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MaterialOrderable", str)
	}
	return nil
}

func (e MaterialOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Mode string

const (
	ModeBatch  Mode = "BATCH"
	ModeSingle Mode = "SINGLE"
)

var AllMode = []Mode{
	ModeBatch,
	ModeSingle,
}

func (e Mode) IsValid() bool {
	switch e {
	case ModeBatch, ModeSingle:
		return true
	}
	return false
}

func (e Mode) String() string {
	return string(e)
}

func (e *Mode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mode", str)
	}
	return nil
}

func (e Mode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OpenSCADDimensionsHasFilter string

const (
	OpenSCADDimensionsHasFilterOpenscad OpenSCADDimensionsHasFilter = "openscad"
	OpenSCADDimensionsHasFilterUnit     OpenSCADDimensionsHasFilter = "unit"
)

var AllOpenSCADDimensionsHasFilter = []OpenSCADDimensionsHasFilter{
	OpenSCADDimensionsHasFilterOpenscad,
	OpenSCADDimensionsHasFilterUnit,
}

func (e OpenSCADDimensionsHasFilter) IsValid() bool {
	switch e {
	case OpenSCADDimensionsHasFilterOpenscad, OpenSCADDimensionsHasFilterUnit:
		return true
	}
	return false
}

func (e OpenSCADDimensionsHasFilter) String() string {
	return string(e)
}

func (e *OpenSCADDimensionsHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OpenSCADDimensionsHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OpenSCADDimensionsHasFilter", str)
	}
	return nil
}

func (e OpenSCADDimensionsHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OpenSCADDimensionsOrderable string

const (
	OpenSCADDimensionsOrderableOpenscad OpenSCADDimensionsOrderable = "openscad"
	OpenSCADDimensionsOrderableUnit     OpenSCADDimensionsOrderable = "unit"
)

var AllOpenSCADDimensionsOrderable = []OpenSCADDimensionsOrderable{
	OpenSCADDimensionsOrderableOpenscad,
	OpenSCADDimensionsOrderableUnit,
}

func (e OpenSCADDimensionsOrderable) IsValid() bool {
	switch e {
	case OpenSCADDimensionsOrderableOpenscad, OpenSCADDimensionsOrderableUnit:
		return true
	}
	return false
}

func (e OpenSCADDimensionsOrderable) String() string {
	return string(e)
}

func (e *OpenSCADDimensionsOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OpenSCADDimensionsOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OpenSCADDimensionsOrderable", str)
	}
	return nil
}

func (e OpenSCADDimensionsOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OuterDimensionsType string

const (
	OuterDimensionsTypeBoundingBoxDimensions OuterDimensionsType = "BoundingBoxDimensions"
	OuterDimensionsTypeOpenSCADDimensions    OuterDimensionsType = "OpenSCADDimensions"
)

var AllOuterDimensionsType = []OuterDimensionsType{
	OuterDimensionsTypeBoundingBoxDimensions,
	OuterDimensionsTypeOpenSCADDimensions,
}

func (e OuterDimensionsType) IsValid() bool {
	switch e {
	case OuterDimensionsTypeBoundingBoxDimensions, OuterDimensionsTypeOpenSCADDimensions:
		return true
	}
	return false
}

func (e OuterDimensionsType) String() string {
	return string(e)
}

func (e *OuterDimensionsType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OuterDimensionsType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OuterDimensionsType", str)
	}
	return nil
}

func (e OuterDimensionsType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductHasFilter string

const (
	ProductHasFilterDiscoveredAt          ProductHasFilter = "discoveredAt"
	ProductHasFilterLastIndexedAt         ProductHasFilter = "lastIndexedAt"
	ProductHasFilterDataSource            ProductHasFilter = "dataSource"
	ProductHasFilterXid                   ProductHasFilter = "xid"
	ProductHasFilterName                  ProductHasFilter = "name"
	ProductHasFilterDescription           ProductHasFilter = "description"
	ProductHasFilterDocumentationLanguage ProductHasFilter = "documentationLanguage"
	ProductHasFilterVersion               ProductHasFilter = "version"
	ProductHasFilterLicense               ProductHasFilter = "license"
	ProductHasFilterLicensor              ProductHasFilter = "licensor"
	ProductHasFilterWebsite               ProductHasFilter = "website"
	ProductHasFilterState                 ProductHasFilter = "state"
	ProductHasFilterLastUpdatedAt         ProductHasFilter = "lastUpdatedAt"
	ProductHasFilterRelease               ProductHasFilter = "release"
	ProductHasFilterReleases              ProductHasFilter = "releases"
	ProductHasFilterRenamedTo             ProductHasFilter = "renamedTo"
	ProductHasFilterRenamedFrom           ProductHasFilter = "renamedFrom"
	ProductHasFilterForkOf                ProductHasFilter = "forkOf"
	ProductHasFilterForks                 ProductHasFilter = "forks"
	ProductHasFilterForkCount             ProductHasFilter = "forkCount"
	ProductHasFilterStarCount             ProductHasFilter = "starCount"
	ProductHasFilterTags                  ProductHasFilter = "tags"
	ProductHasFilterCategory              ProductHasFilter = "category"
)

var AllProductHasFilter = []ProductHasFilter{
	ProductHasFilterDiscoveredAt,
	ProductHasFilterLastIndexedAt,
	ProductHasFilterDataSource,
	ProductHasFilterXid,
	ProductHasFilterName,
	ProductHasFilterDescription,
	ProductHasFilterDocumentationLanguage,
	ProductHasFilterVersion,
	ProductHasFilterLicense,
	ProductHasFilterLicensor,
	ProductHasFilterWebsite,
	ProductHasFilterState,
	ProductHasFilterLastUpdatedAt,
	ProductHasFilterRelease,
	ProductHasFilterReleases,
	ProductHasFilterRenamedTo,
	ProductHasFilterRenamedFrom,
	ProductHasFilterForkOf,
	ProductHasFilterForks,
	ProductHasFilterForkCount,
	ProductHasFilterStarCount,
	ProductHasFilterTags,
	ProductHasFilterCategory,
}

func (e ProductHasFilter) IsValid() bool {
	switch e {
	case ProductHasFilterDiscoveredAt, ProductHasFilterLastIndexedAt, ProductHasFilterDataSource, ProductHasFilterXid, ProductHasFilterName, ProductHasFilterDescription, ProductHasFilterDocumentationLanguage, ProductHasFilterVersion, ProductHasFilterLicense, ProductHasFilterLicensor, ProductHasFilterWebsite, ProductHasFilterState, ProductHasFilterLastUpdatedAt, ProductHasFilterRelease, ProductHasFilterReleases, ProductHasFilterRenamedTo, ProductHasFilterRenamedFrom, ProductHasFilterForkOf, ProductHasFilterForks, ProductHasFilterForkCount, ProductHasFilterStarCount, ProductHasFilterTags, ProductHasFilterCategory:
		return true
	}
	return false
}

func (e ProductHasFilter) String() string {
	return string(e)
}

func (e *ProductHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductHasFilter", str)
	}
	return nil
}

func (e ProductHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductOrderable string

const (
	ProductOrderableDiscoveredAt          ProductOrderable = "discoveredAt"
	ProductOrderableLastIndexedAt         ProductOrderable = "lastIndexedAt"
	ProductOrderableXid                   ProductOrderable = "xid"
	ProductOrderableName                  ProductOrderable = "name"
	ProductOrderableDescription           ProductOrderable = "description"
	ProductOrderableDocumentationLanguage ProductOrderable = "documentationLanguage"
	ProductOrderableVersion               ProductOrderable = "version"
	ProductOrderableWebsite               ProductOrderable = "website"
	ProductOrderableLastUpdatedAt         ProductOrderable = "lastUpdatedAt"
	ProductOrderableForkCount             ProductOrderable = "forkCount"
	ProductOrderableStarCount             ProductOrderable = "starCount"
)

var AllProductOrderable = []ProductOrderable{
	ProductOrderableDiscoveredAt,
	ProductOrderableLastIndexedAt,
	ProductOrderableXid,
	ProductOrderableName,
	ProductOrderableDescription,
	ProductOrderableDocumentationLanguage,
	ProductOrderableVersion,
	ProductOrderableWebsite,
	ProductOrderableLastUpdatedAt,
	ProductOrderableForkCount,
	ProductOrderableStarCount,
}

func (e ProductOrderable) IsValid() bool {
	switch e {
	case ProductOrderableDiscoveredAt, ProductOrderableLastIndexedAt, ProductOrderableXid, ProductOrderableName, ProductOrderableDescription, ProductOrderableDocumentationLanguage, ProductOrderableVersion, ProductOrderableWebsite, ProductOrderableLastUpdatedAt, ProductOrderableForkCount, ProductOrderableStarCount:
		return true
	}
	return false
}

func (e ProductOrderable) String() string {
	return string(e)
}

func (e *ProductOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductOrderable", str)
	}
	return nil
}

func (e ProductOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// ProductState determines the state (activeness) of the product.
type ProductState string

const (
	// State metric has not been determined yet.
	ProductStateUndetermined ProductState = "UNDETERMINED"
	// Product is actively developed.
	ProductStateActive ProductState = "ACTIVE"
	// Product has not received any updates for over 2 years.
	ProductStateInactive ProductState = "INACTIVE"
	// Product repository was marked as archived and thus no longer actively developed.
	ProductStateArchived ProductState = "ARCHIVED"
	// Product was marked as deprecated. There might be a newer version of the product or a different product that acts as a replacement.
	ProductStateDeprecated ProductState = "DEPRECATED"
	// Product source doesn't exists anymore, but its entry is still in the database.
	ProductStateMissing ProductState = "MISSING"
)

var AllProductState = []ProductState{
	ProductStateUndetermined,
	ProductStateActive,
	ProductStateInactive,
	ProductStateArchived,
	ProductStateDeprecated,
	ProductStateMissing,
}

func (e ProductState) IsValid() bool {
	switch e {
	case ProductStateUndetermined, ProductStateActive, ProductStateInactive, ProductStateArchived, ProductStateDeprecated, ProductStateMissing:
		return true
	}
	return false
}

func (e ProductState) String() string {
	return string(e)
}

func (e *ProductState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductState", str)
	}
	return nil
}

func (e ProductState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RepositoryHasFilter string

const (
	RepositoryHasFilterXid       RepositoryHasFilter = "xid"
	RepositoryHasFilterURL       RepositoryHasFilter = "url"
	RepositoryHasFilterPermaURL  RepositoryHasFilter = "permaUrl"
	RepositoryHasFilterHost      RepositoryHasFilter = "host"
	RepositoryHasFilterOwner     RepositoryHasFilter = "owner"
	RepositoryHasFilterName      RepositoryHasFilter = "name"
	RepositoryHasFilterReference RepositoryHasFilter = "reference"
	RepositoryHasFilterPath      RepositoryHasFilter = "path"
	RepositoryHasFilterFile      RepositoryHasFilter = "file"
)

var AllRepositoryHasFilter = []RepositoryHasFilter{
	RepositoryHasFilterXid,
	RepositoryHasFilterURL,
	RepositoryHasFilterPermaURL,
	RepositoryHasFilterHost,
	RepositoryHasFilterOwner,
	RepositoryHasFilterName,
	RepositoryHasFilterReference,
	RepositoryHasFilterPath,
	RepositoryHasFilterFile,
}

func (e RepositoryHasFilter) IsValid() bool {
	switch e {
	case RepositoryHasFilterXid, RepositoryHasFilterURL, RepositoryHasFilterPermaURL, RepositoryHasFilterHost, RepositoryHasFilterOwner, RepositoryHasFilterName, RepositoryHasFilterReference, RepositoryHasFilterPath, RepositoryHasFilterFile:
		return true
	}
	return false
}

func (e RepositoryHasFilter) String() string {
	return string(e)
}

func (e *RepositoryHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryHasFilter", str)
	}
	return nil
}

func (e RepositoryHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RepositoryOrderable string

const (
	RepositoryOrderableXid       RepositoryOrderable = "xid"
	RepositoryOrderableURL       RepositoryOrderable = "url"
	RepositoryOrderablePermaURL  RepositoryOrderable = "permaUrl"
	RepositoryOrderableName      RepositoryOrderable = "name"
	RepositoryOrderableReference RepositoryOrderable = "reference"
	RepositoryOrderablePath      RepositoryOrderable = "path"
)

var AllRepositoryOrderable = []RepositoryOrderable{
	RepositoryOrderableXid,
	RepositoryOrderableURL,
	RepositoryOrderablePermaURL,
	RepositoryOrderableName,
	RepositoryOrderableReference,
	RepositoryOrderablePath,
}

func (e RepositoryOrderable) IsValid() bool {
	switch e {
	case RepositoryOrderableXid, RepositoryOrderableURL, RepositoryOrderablePermaURL, RepositoryOrderableName, RepositoryOrderableReference, RepositoryOrderablePath:
		return true
	}
	return false
}

func (e RepositoryOrderable) String() string {
	return string(e)
}

func (e *RepositoryOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryOrderable", str)
	}
	return nil
}

func (e RepositoryOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The recognized types of repositories.
type RepositoryType string

const (
	RepositoryTypeWebsite RepositoryType = "WEBSITE"
	RepositoryTypeFile    RepositoryType = "FILE"
	RepositoryTypeGit     RepositoryType = "GIT"
)

var AllRepositoryType = []RepositoryType{
	RepositoryTypeWebsite,
	RepositoryTypeFile,
	RepositoryTypeGit,
}

func (e RepositoryType) IsValid() bool {
	switch e {
	case RepositoryTypeWebsite, RepositoryTypeFile, RepositoryTypeGit:
		return true
	}
	return false
}

func (e RepositoryType) String() string {
	return string(e)
}

func (e *RepositoryType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RepositoryType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RepositoryType", str)
	}
	return nil
}

func (e RepositoryType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SoftwareHasFilter string

const (
	SoftwareHasFilterDiscoveredAt          SoftwareHasFilter = "discoveredAt"
	SoftwareHasFilterLastIndexedAt         SoftwareHasFilter = "lastIndexedAt"
	SoftwareHasFilterDataSource            SoftwareHasFilter = "dataSource"
	SoftwareHasFilterRelease               SoftwareHasFilter = "release"
	SoftwareHasFilterInstallationGuide     SoftwareHasFilter = "installationGuide"
	SoftwareHasFilterDocumentationLanguage SoftwareHasFilter = "documentationLanguage"
	SoftwareHasFilterLicense               SoftwareHasFilter = "license"
	SoftwareHasFilterLicensor              SoftwareHasFilter = "licensor"
)

var AllSoftwareHasFilter = []SoftwareHasFilter{
	SoftwareHasFilterDiscoveredAt,
	SoftwareHasFilterLastIndexedAt,
	SoftwareHasFilterDataSource,
	SoftwareHasFilterRelease,
	SoftwareHasFilterInstallationGuide,
	SoftwareHasFilterDocumentationLanguage,
	SoftwareHasFilterLicense,
	SoftwareHasFilterLicensor,
}

func (e SoftwareHasFilter) IsValid() bool {
	switch e {
	case SoftwareHasFilterDiscoveredAt, SoftwareHasFilterLastIndexedAt, SoftwareHasFilterDataSource, SoftwareHasFilterRelease, SoftwareHasFilterInstallationGuide, SoftwareHasFilterDocumentationLanguage, SoftwareHasFilterLicense, SoftwareHasFilterLicensor:
		return true
	}
	return false
}

func (e SoftwareHasFilter) String() string {
	return string(e)
}

func (e *SoftwareHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SoftwareHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SoftwareHasFilter", str)
	}
	return nil
}

func (e SoftwareHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SoftwareOrderable string

const (
	SoftwareOrderableDiscoveredAt          SoftwareOrderable = "discoveredAt"
	SoftwareOrderableLastIndexedAt         SoftwareOrderable = "lastIndexedAt"
	SoftwareOrderableRelease               SoftwareOrderable = "release"
	SoftwareOrderableDocumentationLanguage SoftwareOrderable = "documentationLanguage"
	SoftwareOrderableLicensor              SoftwareOrderable = "licensor"
)

var AllSoftwareOrderable = []SoftwareOrderable{
	SoftwareOrderableDiscoveredAt,
	SoftwareOrderableLastIndexedAt,
	SoftwareOrderableRelease,
	SoftwareOrderableDocumentationLanguage,
	SoftwareOrderableLicensor,
}

func (e SoftwareOrderable) IsValid() bool {
	switch e {
	case SoftwareOrderableDiscoveredAt, SoftwareOrderableLastIndexedAt, SoftwareOrderableRelease, SoftwareOrderableDocumentationLanguage, SoftwareOrderableLicensor:
		return true
	}
	return false
}

func (e SoftwareOrderable) String() string {
	return string(e)
}

func (e *SoftwareOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SoftwareOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SoftwareOrderable", str)
	}
	return nil
}

func (e SoftwareOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StringOrFloatType string

const (
	StringOrFloatTypeStringV StringOrFloatType = "StringV"
	StringOrFloatTypeFloatV  StringOrFloatType = "FloatV"
)

var AllStringOrFloatType = []StringOrFloatType{
	StringOrFloatTypeStringV,
	StringOrFloatTypeFloatV,
}

func (e StringOrFloatType) IsValid() bool {
	switch e {
	case StringOrFloatTypeStringV, StringOrFloatTypeFloatV:
		return true
	}
	return false
}

func (e StringOrFloatType) String() string {
	return string(e)
}

func (e *StringOrFloatType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StringOrFloatType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StringOrFloatType", str)
	}
	return nil
}

func (e StringOrFloatType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StringVHasFilter string

const (
	StringVHasFilterValue StringVHasFilter = "value"
)

var AllStringVHasFilter = []StringVHasFilter{
	StringVHasFilterValue,
}

func (e StringVHasFilter) IsValid() bool {
	switch e {
	case StringVHasFilterValue:
		return true
	}
	return false
}

func (e StringVHasFilter) String() string {
	return string(e)
}

func (e *StringVHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StringVHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StringVHasFilter", str)
	}
	return nil
}

func (e StringVHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StringVOrderable string

const (
	StringVOrderableValue StringVOrderable = "value"
)

var AllStringVOrderable = []StringVOrderable{
	StringVOrderableValue,
}

func (e StringVOrderable) IsValid() bool {
	switch e {
	case StringVOrderableValue:
		return true
	}
	return false
}

func (e StringVOrderable) String() string {
	return string(e)
}

func (e *StringVOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StringVOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StringVOrderable", str)
	}
	return nil
}

func (e StringVOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagHasFilter string

const (
	TagHasFilterXid     TagHasFilter = "xid"
	TagHasFilterName    TagHasFilter = "name"
	TagHasFilterAliases TagHasFilter = "aliases"
	TagHasFilterRelated TagHasFilter = "related"
)

var AllTagHasFilter = []TagHasFilter{
	TagHasFilterXid,
	TagHasFilterName,
	TagHasFilterAliases,
	TagHasFilterRelated,
}

func (e TagHasFilter) IsValid() bool {
	switch e {
	case TagHasFilterXid, TagHasFilterName, TagHasFilterAliases, TagHasFilterRelated:
		return true
	}
	return false
}

func (e TagHasFilter) String() string {
	return string(e)
}

func (e *TagHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagHasFilter", str)
	}
	return nil
}

func (e TagHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagOrderable string

const (
	TagOrderableXid  TagOrderable = "xid"
	TagOrderableName TagOrderable = "name"
)

var AllTagOrderable = []TagOrderable{
	TagOrderableXid,
	TagOrderableName,
}

func (e TagOrderable) IsValid() bool {
	switch e {
	case TagOrderableXid, TagOrderableName:
		return true
	}
	return false
}

func (e TagOrderable) String() string {
	return string(e)
}

func (e *TagOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagOrderable", str)
	}
	return nil
}

func (e TagOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TechnicalStandardHasFilter string

const (
	TechnicalStandardHasFilterXid         TechnicalStandardHasFilter = "xid"
	TechnicalStandardHasFilterName        TechnicalStandardHasFilter = "name"
	TechnicalStandardHasFilterDescription TechnicalStandardHasFilter = "description"
	TechnicalStandardHasFilterComponents  TechnicalStandardHasFilter = "components"
)

var AllTechnicalStandardHasFilter = []TechnicalStandardHasFilter{
	TechnicalStandardHasFilterXid,
	TechnicalStandardHasFilterName,
	TechnicalStandardHasFilterDescription,
	TechnicalStandardHasFilterComponents,
}

func (e TechnicalStandardHasFilter) IsValid() bool {
	switch e {
	case TechnicalStandardHasFilterXid, TechnicalStandardHasFilterName, TechnicalStandardHasFilterDescription, TechnicalStandardHasFilterComponents:
		return true
	}
	return false
}

func (e TechnicalStandardHasFilter) String() string {
	return string(e)
}

func (e *TechnicalStandardHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TechnicalStandardHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TechnicalStandardHasFilter", str)
	}
	return nil
}

func (e TechnicalStandardHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TechnicalStandardOrderable string

const (
	TechnicalStandardOrderableXid         TechnicalStandardOrderable = "xid"
	TechnicalStandardOrderableName        TechnicalStandardOrderable = "name"
	TechnicalStandardOrderableDescription TechnicalStandardOrderable = "description"
)

var AllTechnicalStandardOrderable = []TechnicalStandardOrderable{
	TechnicalStandardOrderableXid,
	TechnicalStandardOrderableName,
	TechnicalStandardOrderableDescription,
}

func (e TechnicalStandardOrderable) IsValid() bool {
	switch e {
	case TechnicalStandardOrderableXid, TechnicalStandardOrderableName, TechnicalStandardOrderableDescription:
		return true
	}
	return false
}

func (e TechnicalStandardOrderable) String() string {
	return string(e)
}

func (e *TechnicalStandardOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TechnicalStandardOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TechnicalStandardOrderable", str)
	}
	return nil
}

func (e TechnicalStandardOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// The technology readiness levels of components.
type TechnologyReadinessLevel string

const (
	TechnologyReadinessLevelUndetermined TechnologyReadinessLevel = "UNDETERMINED"
	TechnologyReadinessLevelOtrl1        TechnologyReadinessLevel = "OTRL_1"
	TechnologyReadinessLevelOtrl2        TechnologyReadinessLevel = "OTRL_2"
	TechnologyReadinessLevelOtrl3        TechnologyReadinessLevel = "OTRL_3"
	TechnologyReadinessLevelOtrl4        TechnologyReadinessLevel = "OTRL_4"
	TechnologyReadinessLevelOtrl5        TechnologyReadinessLevel = "OTRL_5"
)

var AllTechnologyReadinessLevel = []TechnologyReadinessLevel{
	TechnologyReadinessLevelUndetermined,
	TechnologyReadinessLevelOtrl1,
	TechnologyReadinessLevelOtrl2,
	TechnologyReadinessLevelOtrl3,
	TechnologyReadinessLevelOtrl4,
	TechnologyReadinessLevelOtrl5,
}

func (e TechnologyReadinessLevel) IsValid() bool {
	switch e {
	case TechnologyReadinessLevelUndetermined, TechnologyReadinessLevelOtrl1, TechnologyReadinessLevelOtrl2, TechnologyReadinessLevelOtrl3, TechnologyReadinessLevelOtrl4, TechnologyReadinessLevelOtrl5:
		return true
	}
	return false
}

func (e TechnologyReadinessLevel) String() string {
	return string(e)
}

func (e *TechnologyReadinessLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TechnologyReadinessLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TechnologyReadinessLevel", str)
	}
	return nil
}

func (e TechnologyReadinessLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TechnologySpecificDocumentationCriteriaHasFilter string

const (
	TechnologySpecificDocumentationCriteriaHasFilterXid             TechnologySpecificDocumentationCriteriaHasFilter = "xid"
	TechnologySpecificDocumentationCriteriaHasFilterName            TechnologySpecificDocumentationCriteriaHasFilter = "name"
	TechnologySpecificDocumentationCriteriaHasFilterComment         TechnologySpecificDocumentationCriteriaHasFilter = "comment"
	TechnologySpecificDocumentationCriteriaHasFilterRequirementsURI TechnologySpecificDocumentationCriteriaHasFilter = "requirementsUri"
	TechnologySpecificDocumentationCriteriaHasFilterComponents      TechnologySpecificDocumentationCriteriaHasFilter = "components"
)

var AllTechnologySpecificDocumentationCriteriaHasFilter = []TechnologySpecificDocumentationCriteriaHasFilter{
	TechnologySpecificDocumentationCriteriaHasFilterXid,
	TechnologySpecificDocumentationCriteriaHasFilterName,
	TechnologySpecificDocumentationCriteriaHasFilterComment,
	TechnologySpecificDocumentationCriteriaHasFilterRequirementsURI,
	TechnologySpecificDocumentationCriteriaHasFilterComponents,
}

func (e TechnologySpecificDocumentationCriteriaHasFilter) IsValid() bool {
	switch e {
	case TechnologySpecificDocumentationCriteriaHasFilterXid, TechnologySpecificDocumentationCriteriaHasFilterName, TechnologySpecificDocumentationCriteriaHasFilterComment, TechnologySpecificDocumentationCriteriaHasFilterRequirementsURI, TechnologySpecificDocumentationCriteriaHasFilterComponents:
		return true
	}
	return false
}

func (e TechnologySpecificDocumentationCriteriaHasFilter) String() string {
	return string(e)
}

func (e *TechnologySpecificDocumentationCriteriaHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TechnologySpecificDocumentationCriteriaHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TechnologySpecificDocumentationCriteriaHasFilter", str)
	}
	return nil
}

func (e TechnologySpecificDocumentationCriteriaHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TechnologySpecificDocumentationCriteriaOrderable string

const (
	TechnologySpecificDocumentationCriteriaOrderableXid             TechnologySpecificDocumentationCriteriaOrderable = "xid"
	TechnologySpecificDocumentationCriteriaOrderableName            TechnologySpecificDocumentationCriteriaOrderable = "name"
	TechnologySpecificDocumentationCriteriaOrderableComment         TechnologySpecificDocumentationCriteriaOrderable = "comment"
	TechnologySpecificDocumentationCriteriaOrderableRequirementsURI TechnologySpecificDocumentationCriteriaOrderable = "requirementsUri"
)

var AllTechnologySpecificDocumentationCriteriaOrderable = []TechnologySpecificDocumentationCriteriaOrderable{
	TechnologySpecificDocumentationCriteriaOrderableXid,
	TechnologySpecificDocumentationCriteriaOrderableName,
	TechnologySpecificDocumentationCriteriaOrderableComment,
	TechnologySpecificDocumentationCriteriaOrderableRequirementsURI,
}

func (e TechnologySpecificDocumentationCriteriaOrderable) IsValid() bool {
	switch e {
	case TechnologySpecificDocumentationCriteriaOrderableXid, TechnologySpecificDocumentationCriteriaOrderableName, TechnologySpecificDocumentationCriteriaOrderableComment, TechnologySpecificDocumentationCriteriaOrderableRequirementsURI:
		return true
	}
	return false
}

func (e TechnologySpecificDocumentationCriteriaOrderable) String() string {
	return string(e)
}

func (e *TechnologySpecificDocumentationCriteriaOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TechnologySpecificDocumentationCriteriaOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TechnologySpecificDocumentationCriteriaOrderable", str)
	}
	return nil
}

func (e TechnologySpecificDocumentationCriteriaOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserHasFilter string

const (
	UserHasFilterXid      UserHasFilter = "xid"
	UserHasFilterHost     UserHasFilter = "host"
	UserHasFilterName     UserHasFilter = "name"
	UserHasFilterFullName UserHasFilter = "fullName"
	UserHasFilterEmail    UserHasFilter = "email"
	UserHasFilterAvatar   UserHasFilter = "avatar"
	UserHasFilterURL      UserHasFilter = "url"
	UserHasFilterMemberOf UserHasFilter = "memberOf"
	UserHasFilterProducts UserHasFilter = "products"
	UserHasFilterLocale   UserHasFilter = "locale"
)

var AllUserHasFilter = []UserHasFilter{
	UserHasFilterXid,
	UserHasFilterHost,
	UserHasFilterName,
	UserHasFilterFullName,
	UserHasFilterEmail,
	UserHasFilterAvatar,
	UserHasFilterURL,
	UserHasFilterMemberOf,
	UserHasFilterProducts,
	UserHasFilterLocale,
}

func (e UserHasFilter) IsValid() bool {
	switch e {
	case UserHasFilterXid, UserHasFilterHost, UserHasFilterName, UserHasFilterFullName, UserHasFilterEmail, UserHasFilterAvatar, UserHasFilterURL, UserHasFilterMemberOf, UserHasFilterProducts, UserHasFilterLocale:
		return true
	}
	return false
}

func (e UserHasFilter) String() string {
	return string(e)
}

func (e *UserHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHasFilter", str)
	}
	return nil
}

func (e UserHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrGroupHasFilter string

const (
	UserOrGroupHasFilterXid      UserOrGroupHasFilter = "xid"
	UserOrGroupHasFilterHost     UserOrGroupHasFilter = "host"
	UserOrGroupHasFilterName     UserOrGroupHasFilter = "name"
	UserOrGroupHasFilterFullName UserOrGroupHasFilter = "fullName"
	UserOrGroupHasFilterEmail    UserOrGroupHasFilter = "email"
	UserOrGroupHasFilterAvatar   UserOrGroupHasFilter = "avatar"
	UserOrGroupHasFilterURL      UserOrGroupHasFilter = "url"
	UserOrGroupHasFilterMemberOf UserOrGroupHasFilter = "memberOf"
	UserOrGroupHasFilterProducts UserOrGroupHasFilter = "products"
)

var AllUserOrGroupHasFilter = []UserOrGroupHasFilter{
	UserOrGroupHasFilterXid,
	UserOrGroupHasFilterHost,
	UserOrGroupHasFilterName,
	UserOrGroupHasFilterFullName,
	UserOrGroupHasFilterEmail,
	UserOrGroupHasFilterAvatar,
	UserOrGroupHasFilterURL,
	UserOrGroupHasFilterMemberOf,
	UserOrGroupHasFilterProducts,
}

func (e UserOrGroupHasFilter) IsValid() bool {
	switch e {
	case UserOrGroupHasFilterXid, UserOrGroupHasFilterHost, UserOrGroupHasFilterName, UserOrGroupHasFilterFullName, UserOrGroupHasFilterEmail, UserOrGroupHasFilterAvatar, UserOrGroupHasFilterURL, UserOrGroupHasFilterMemberOf, UserOrGroupHasFilterProducts:
		return true
	}
	return false
}

func (e UserOrGroupHasFilter) String() string {
	return string(e)
}

func (e *UserOrGroupHasFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrGroupHasFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrGroupHasFilter", str)
	}
	return nil
}

func (e UserOrGroupHasFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrGroupOrderable string

const (
	UserOrGroupOrderableXid      UserOrGroupOrderable = "xid"
	UserOrGroupOrderableName     UserOrGroupOrderable = "name"
	UserOrGroupOrderableFullName UserOrGroupOrderable = "fullName"
	UserOrGroupOrderableEmail    UserOrGroupOrderable = "email"
	UserOrGroupOrderableURL      UserOrGroupOrderable = "url"
)

var AllUserOrGroupOrderable = []UserOrGroupOrderable{
	UserOrGroupOrderableXid,
	UserOrGroupOrderableName,
	UserOrGroupOrderableFullName,
	UserOrGroupOrderableEmail,
	UserOrGroupOrderableURL,
}

func (e UserOrGroupOrderable) IsValid() bool {
	switch e {
	case UserOrGroupOrderableXid, UserOrGroupOrderableName, UserOrGroupOrderableFullName, UserOrGroupOrderableEmail, UserOrGroupOrderableURL:
		return true
	}
	return false
}

func (e UserOrGroupOrderable) String() string {
	return string(e)
}

func (e *UserOrGroupOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrGroupOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrGroupOrderable", str)
	}
	return nil
}

func (e UserOrGroupOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserOrderable string

const (
	UserOrderableXid      UserOrderable = "xid"
	UserOrderableName     UserOrderable = "name"
	UserOrderableFullName UserOrderable = "fullName"
	UserOrderableEmail    UserOrderable = "email"
	UserOrderableURL      UserOrderable = "url"
	UserOrderableLocale   UserOrderable = "locale"
)

var AllUserOrderable = []UserOrderable{
	UserOrderableXid,
	UserOrderableName,
	UserOrderableFullName,
	UserOrderableEmail,
	UserOrderableURL,
	UserOrderableLocale,
}

func (e UserOrderable) IsValid() bool {
	switch e {
	case UserOrderableXid, UserOrderableName, UserOrderableFullName, UserOrderableEmail, UserOrderableURL, UserOrderableLocale:
		return true
	}
	return false
}

func (e UserOrderable) String() string {
	return string(e)
}

func (e *UserOrderable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderable", str)
	}
	return nil
}

func (e UserOrderable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
